%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{Programação para Geoprocessamento}
\date{Nov 22, 2023}
\release{}
\author{Alexandro Gularte Schafer}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{intro::doc}}


\sphinxAtStartPar
This is a small sample book to give you a feel for how book content is
structured.
It shows off a few of the major file types, as well as some sample content.
It does not go in\sphinxhyphen{}depth into any particular topic \sphinxhyphen{} check out \sphinxhref{https://jupyterbook.org}{the Jupyter Book documentation} for more information.

\sphinxAtStartPar
Check out the content pages bundled with this sample book to see more.
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{markdown::doc}]{\sphinxcrossref{Markdown Files}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{notebooks::doc}]{\sphinxcrossref{Content with notebooks}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{markdown-notebooks::doc}]{\sphinxcrossref{Notebooks with MyST Markdown}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{introducao::doc}]{\sphinxcrossref{1. INTRODUÇÃO}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{capitulo2::doc}]{\sphinxcrossref{2. FUNDAMENTOS DA LINGUAGEM PYTHON}}}

\end{itemize}

\sphinxstepscope


\chapter{Markdown Files}
\label{\detokenize{markdown:markdown-files}}\label{\detokenize{markdown::doc}}
\sphinxAtStartPar
Whether you write your book’s content in Jupyter Notebooks (\sphinxcode{\sphinxupquote{.ipynb}}) or
in regular markdown files (\sphinxcode{\sphinxupquote{.md}}), you’ll write in the same flavor of markdown
called \sphinxstylestrong{MyST Markdown}.
This is a simple file to help you get started and show off some syntax.


\section{What is MyST?}
\label{\detokenize{markdown:what-is-myst}}
\sphinxAtStartPar
MyST stands for “Markedly Structured Text”. It
is a slight variation on a flavor of markdown called “CommonMark” markdown,
with small syntax extensions to allow you to write \sphinxstylestrong{roles} and \sphinxstylestrong{directives}
in the Sphinx ecosystem.

\sphinxAtStartPar
For more about MyST, see \sphinxhref{https://jupyterbook.org/content/myst.html}{the MyST Markdown Overview}.


\section{Sample Roles and Directives}
\label{\detokenize{markdown:sample-roles-and-directives}}
\sphinxAtStartPar
Roles and directives are two of the most powerful tools in Jupyter Book. They
are kind of like functions, but written in a markup language. They both
serve a similar purpose, but \sphinxstylestrong{roles are written in one line}, whereas
\sphinxstylestrong{directives span many lines}. They both accept different kinds of inputs,
and what they do with those inputs depends on the specific role or directive
that is being called.

\sphinxAtStartPar
Here is a “note” directive:

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Here is a note
\end{sphinxadmonition}

\sphinxAtStartPar
It will be rendered in a special box when you build your book.

\sphinxAtStartPar
Here is an inline directive to refer to a document: {\hyperref[\detokenize{markdown-notebooks::doc}]{\sphinxcrossref{\DUrole{doc}{Notebooks with MyST Markdown}}}}.


\section{Citations}
\label{\detokenize{markdown:citations}}
\sphinxAtStartPar
You can also cite references that are stored in a \sphinxcode{\sphinxupquote{bibtex}} file. For example,
the following syntax: \sphinxcode{\sphinxupquote{\{cite\}`holdgraf\_evidence\_2014`}} will render like
this: {[}\hyperlink{cite.markdown:id3}{HdHPK14}{]}.

\sphinxAtStartPar
Moreover, you can insert a bibliography into your page with this syntax:
The \sphinxcode{\sphinxupquote{\{bibliography\}}} directive must be used for all the \sphinxcode{\sphinxupquote{\{cite\}}} roles to
render properly.
For example, if the references for your book are stored in \sphinxcode{\sphinxupquote{references.bib}},
then the bibliography is inserted with:


\section{Learn more}
\label{\detokenize{markdown:learn-more}}
\sphinxAtStartPar
This is just a simple starter to get you started.
You can learn a lot more at \sphinxhref{https://jupyterbook.org}{jupyterbook.org}.

\sphinxstepscope


\chapter{Content with notebooks}
\label{\detokenize{notebooks:content-with-notebooks}}\label{\detokenize{notebooks::doc}}
\sphinxAtStartPar
You can also create content with Jupyter Notebooks. This means that you can include
code blocks and their outputs in your book.


\section{Markdown + notebooks}
\label{\detokenize{notebooks:markdown-notebooks}}
\sphinxAtStartPar
As it is markdown, you can embed images, HTML, etc into your posts!

\sphinxAtStartPar
\sphinxincludegraphics{{logo-wide}.png}

\sphinxAtStartPar
You can also \(add_{math}\) and
\begin{equation*}
\begin{split}
math^{blocks}
\end{split}
\end{equation*}
\sphinxAtStartPar
or
\begin{equation*}
\begin{split}
\begin{aligned}
\mbox{mean} la_{tex} \\ \\
math blocks
\end{aligned}
\end{split}
\end{equation*}
\sphinxAtStartPar
But make sure you \$Escape \$your \$dollar signs \$you want to keep!


\section{MyST markdown}
\label{\detokenize{notebooks:myst-markdown}}
\sphinxAtStartPar
MyST markdown works in Jupyter Notebooks as well. For more information about MyST markdown, check
out \sphinxhref{https://jupyterbook.org/content/myst.html}{the MyST guide in Jupyter Book},
or see \sphinxhref{https://myst-parser.readthedocs.io/en/latest/}{the MyST markdown documentation}.


\section{Code blocks and outputs}
\label{\detokenize{notebooks:code-blocks-and-outputs}}
\sphinxAtStartPar
Jupyter Book will also embed your code blocks and output in your book.
For example, here’s some sample Matplotlib code:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{rcParams}\PYG{p}{,} \PYG{n}{cycler}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ion}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.pyplot.\PYGZus{}IonContext at 0x7f54ca2829d0\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Fixing random state for reproducibility}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{19680801}\PYG{p}{)}

\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{logspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)} \PYG{o}{+} \PYG{n}{ii} \PYG{k}{for} \PYG{n}{ii} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{coolwarm}
\PYG{n}{rcParams}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{axes.prop\PYGZus{}cycle}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{cycler}\PYG{p}{(}\PYG{n}{color}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}


\PYG{k+kn}{from} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{lines} \PYG{k+kn}{import} \PYG{n}{Line2D}
\PYG{n}{custom\PYGZus{}lines} \PYG{o}{=} \PYG{p}{[}\PYG{n}{Line2D}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{(}\PYG{l+m+mf}{0.}\PYG{p}{)}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}
                \PYG{n}{Line2D}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{(}\PYG{l+m+mf}{.5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}
                \PYG{n}{Line2D}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{]}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{lines} \PYG{o}{=} \PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{custom\PYGZus{}lines}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cold}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Medium}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hot}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{63e30431ae9411e8b5ea3ce082aa66830cbb7591d4798cd3ecdc557d67de7434}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
There is a lot more that you can do with outputs (such as including interactive outputs)
with your book. For more information about this, see \sphinxhref{https://jupyterbook.org}{the Jupyter Book documentation}

\sphinxstepscope


\chapter{Notebooks with MyST Markdown}
\label{\detokenize{markdown-notebooks:notebooks-with-myst-markdown}}\label{\detokenize{markdown-notebooks::doc}}
\sphinxAtStartPar
Jupyter Book also lets you write text\sphinxhyphen{}based notebooks using MyST Markdown.
See \sphinxhref{https://jupyterbook.org/file-types/myst-notebooks.html}{the Notebooks with MyST Markdown documentation} for more detailed instructions.
This page shows off a notebook written in MyST Markdown.


\section{An example cell}
\label{\detokenize{markdown-notebooks:an-example-cell}}
\sphinxAtStartPar
With MyST Markdown, you can define code cells with a directive like so:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
4
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
When your book is built, the contents of any \sphinxcode{\sphinxupquote{\{code\sphinxhyphen{}cell\}}} blocks will be
executed with your default Jupyter kernel, and their outputs will be displayed
in\sphinxhyphen{}line with the rest of your content.


\sphinxstrong{See also:}
\nopagebreak


\sphinxAtStartPar
Jupyter Book uses \sphinxhref{https://jupytext.readthedocs.io/en/latest/}{Jupytext} to convert text\sphinxhyphen{}based files to notebooks, and can support \sphinxhref{https://jupyterbook.org/file-types/jupytext.html}{many other text\sphinxhyphen{}based notebook files}.




\section{Create a notebook with MyST Markdown}
\label{\detokenize{markdown-notebooks:create-a-notebook-with-myst-markdown}}
\sphinxAtStartPar
MyST Markdown notebooks are defined by two things:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
YAML metadata that is needed to understand if / how it should convert text files to notebooks (including information about the kernel needed).
See the YAML at the top of this page for example.

\item {} 
\sphinxAtStartPar
The presence of \sphinxcode{\sphinxupquote{\{code\sphinxhyphen{}cell\}}} directives, which will be executed with your book.

\end{enumerate}

\sphinxAtStartPar
That’s all that is needed to get started!


\section{Quickly add YAML metadata for MyST Notebooks}
\label{\detokenize{markdown-notebooks:quickly-add-yaml-metadata-for-myst-notebooks}}
\sphinxAtStartPar
If you have a markdown file and you’d like to quickly add YAML metadata to it, so that Jupyter Book will treat it as a MyST Markdown Notebook, run the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{jupyter}\PYG{o}{\PYGZhy{}}\PYG{n}{book} \PYG{n}{myst} \PYG{n}{init} \PYG{n}{path}\PYG{o}{/}\PYG{n}{to}\PYG{o}{/}\PYG{n}{markdownfile}\PYG{o}{.}\PYG{n}{md}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{1. INTRODUÇÃO}
\label{\detokenize{introducao:introducao}}\label{\detokenize{introducao::doc}}
\sphinxAtStartPar
A análise geoespacial contemporânea pode ser facilmente realizada por meio de pacotes geoespaciais comerciais ou de código aberto intuitivos, bastando, muitas vezes, um simples clique. Entretanto, surge a pergunta: por que optar por aprender uma linguagem de programação nesse contexto? As principais razões incluem: a) Busca por controle total sobre algoritmos, dados e execução; b) Necessidade de automatizar tarefas analíticas específicas e recorrentes sem a complexidade de um extenso framework geoespacial; c) Intenção de desenvolver um programa facilmente compartilhável; d) Vontade de aprofundar o conhecimento em análise geoespacial, indo além do uso superficial de softwares.

\sphinxAtStartPar
A programação é fundamental no geoprocessamento devido a sua capacidade de permitir que os profissionais processem, analisem e visualizem grandes volumes de dados geoespaciais de forma eficiente e automatizada. Muitas das tarefas associadas ao geoprocessamento, como coleta, limpeza, processamento e análise de dados, são repetitivas e, com a programação, podem ser automatizadas, economizando tempo e permitindo um foco maior em desafios analíticos mais intrincados. Linguagens como Python e R, por exemplo, proporcionam escalabilidade, sendo aptas para integrar\sphinxhyphen{}se a sistemas maiores e processar grandes volumes de dados com a ajuda de bibliotecas especializadas. Em contraste, softwares desktop podem enfrentar limitações em conjuntos de dados extensos e podem não se adaptar tão bem a aplicações em nuvem ou infraestruturas de TI mais robustas.

\sphinxAtStartPar
A capacidade de lidar com vastos conjuntos de dados geoespaciais é uma característica marcante da programação. Linguagens de programação, como Python, vêm equipadas com ferramentas potentes para essa finalidade. Além disso, elas oferecem flexibilidade incomparável para criar soluções sob medida, desenvolver novos algoritmos e amalgamar diferentes fontes de dados. Tarefas avançadas, como análises de padrões espaciais, modelagem preditiva e simulação, tornam\sphinxhyphen{}se mais viáveis através da programação.
Outra vantagem é a visualização de dados. Com bibliotecas específicas, é possível criar desde mapas simples até visualizações interativas sofisticadas. A programação também promove a reprodutibilidade, permitindo que análises sejam facilmente replicadas e compartilhadas, um aspecto crítico em ciências. No contexto do geoprocessamento, a capacidade de integrar dados de múltiplas fontes, sejam elas imagens de satélite, dados de GPS ou censos, é uma necessidade, e a programação é uma solução eficaz para isso.

\sphinxAtStartPar
A integração com outras tecnologias, como bancos de dados, aplicações web e sistemas de aprendizado de máquina, é facilitada pela programação. E, do ponto de vista econômico, a existência de bibliotecas e ferramentas de programação GIS de código aberto pode significar reduções de custo. Estas ferramentas, muitas vezes apoiadas por comunidades ativas, aceleram a inovação, fornecem suporte e disponibilizam recursos educacionais.

\sphinxAtStartPar
Apesar das vantagens da utilização da programação, não se pode negar o valor dos softwares desktop GIS. Eles frequentemente se apresentam como mais acessíveis para indivíduos que não possuem experiência em programação. Suas interfaces gráficas são geralmente intuitivas, facilitando a visualização, a exploração inicial de dados e a realização de tarefas simples. Além disso, muitos destes softwares vêm com uma vasta biblioteca de funções e ferramentas, economizando tempo em operações comuns. Também há de se considerar a robustez e a estabilidade de algumas destas aplicações, que foram aprimoradas ao longo de anos. Muitos profissionais e pesquisadores, reconhecendo a importância de ambas as abordagens, optam por utilizar uma combinação delas, assimilando o melhor que cada uma tem a oferecer.


\section{1.1 Linguagens de programação em Geoprocessamento}
\label{\detokenize{introducao:linguagens-de-programacao-em-geoprocessamento}}
\sphinxAtStartPar
Existe grande número de linguagens de programação utilizadas em trabalhos que envolvem o geoprocessamento. Algumas das principais linguagens de programação e suas aplicações específicas na área incluem:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Python: É uma das linguagens mais populares no campo de geoprocessamento. Muitos softwares GIS, como o QGIS e ArcGIS, oferecem interfaces de script baseadas em Python. Bibliotecas populares em Python para geoprocessamento incluem GDAL, Geopandas, Shapely, Fiona, PyProj, entre outras;

\item {} 
\sphinxAtStartPar
R: Principalmente conhecido por análise estatística, R também possui pacotes, como sf (Simple Features) e sp (Spatial), que o tornam adequado para análise espacial e geoprocessamento;

\item {} 
\sphinxAtStartPar
JavaScript: Com o aumento dos mapas interativos online, o JavaScript se tornou crucial no geoprocessamento web. Bibliotecas como Leaflet e OpenLayers permitem criar visualizações de mapas interativas em websites;

\item {} 
\sphinxAtStartPar
SQL: Muitos sistemas de bancos de dados espaciais, como PostGIS (uma extensão do PostgreSQL), utilizam SQL para consultas e manipulações espaciais. As extensões espaciais de SQL permitem operações como interseção, união e buffer diretamente no banco de dados;

\item {} 
\sphinxAtStartPar
Java: Softwares como GeoServer e algumas bibliotecas GIS, como Geotools, são baseados em Java. Também é usado em aplicações Android que têm capacidades GIS;

\item {} 
\sphinxAtStartPar
C++ e C: Algumas das plataformas de geoprocessamento, como GDAL, são escritas em C ou C++. Elas oferecem desempenho e são usadas para tarefas intensivas de processamento”;

\item {} 
\sphinxAtStartPar
.NET/C\#: O ArcGIS, da Esri, oferece uma API para desenvolvimento baseada em .NET. Assim, desenvolvedores que trabalham com plataformas Esri muitas vezes usam C\# para personalizações e desenvolvimento de plugins;

\end{itemize}

\sphinxAtStartPar
Estas são apenas algumas das linguagens e tecnologias no vasto campo do geoprocessamento e SIG. Dependendo das necessidades específicas do projeto, outras linguagens e ferramentas podem ser mais apropriadas.

\sphinxAtStartPar
\sphinxstyleemphasis{A linguagem Python}

\sphinxAtStartPar
Python é uma linguagem de programação de alto nível, interpretada, de script, imperativa, orientada a objetos, funcional e de tipagem dinâmica. Foi criada por Guido Van Rossum durante 1985\sphinxhyphen{}1990 e teve sua primeira versão lançada em 1991. Em 2020, o Python se tornou uma das linguagens de programação mais populares, sendo amplamente usada em áreas como análise de dados, aprendizado de máquina, automação, desenvolvimento web e, claro, geoprocessamento.
O Python continua a ser desenvolvido e melhorado, com novas versões sendo lançadas regularmente. Como linguagem, o Python manteve seu foco original na facilidade de leitura, simplicidade e explicitação, tornando\sphinxhyphen{}se um favorito tanto para iniciantes quanto para programadores experientes. Aqui estão algumas das características do Python:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Código legível: utiliza indentação para delinear blocos de código, ao contrário de outras linguagens que usam chaves ou palavras\sphinxhyphen{}chave específicas. Esta característica torna o código Python mais limpo e fácil de entender, facilitando a leitura e a manutenção do código;

\item {} 
\sphinxAtStartPar
Orientação a objetos: suporta programação orientada a objetos, permitindo que os conceitos de classes e objetos sejam utilizados para modelar o mundo real de uma maneira que pode ser intuitiva para muitos;

\item {} 
\sphinxAtStartPar
Interpretado: é uma linguagem interpretada, o que significa que o código Python é executado linha por linha, o que facilita a depuração, permitindo ainda uma experiência interativa de programação que pode ser especialmente útil para prototipagem e experimentação;

\item {} 
\sphinxAtStartPar
Tipagem dinâmica: é uma linguagem de tipagem dinâmica. Isto significa que o tipo de uma variável é determinado em tempo de execução, e não precisa ser especificado quando a variável é declarada. Isso pode aumentar a flexibilidade e a facilidade de uso do Python, embora também possa levar a erros se os programadores não estiverem cientes do tipo de uma variável;

\item {} 
\sphinxAtStartPar
Biblioteca padrão rica e extensiva: Python vem com uma biblioteca padrão rica que inclui módulos para uma variedade de tarefas, incluindo manipulação de arquivos, conexões de rede, gerenciamento de tempo, entre outros;

\item {} 
\sphinxAtStartPar
Ecossistema de pacotes de terceiros: Além da biblioteca padrão, Python tem um ecossistema extenso de bibliotecas de terceiros disponíveis que abrangem desde desenvolvimento web e bancos de dados até visualização de dados e aprendizado de máquina;

\item {} 
\sphinxAtStartPar
Portabilidade: é uma linguagem de programação multiplataforma, o que significa que o mesmo código Python pode ser executado em diferentes sistemas operacionais com pouca ou nenhuma modificação;

\item {} 
\sphinxAtStartPar
Comunidade ativa e crescente: Python tem uma grande e ativa comunidade de programadores que contribuem para a melhoria constante da linguagem, além de fornecer suporte através de fóruns e sites de perguntas e respostas.

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{Domínios de aplicação da linguagem Python}

\sphinxAtStartPar
Python é uma linguagem de programação que vem sendo utilizada em uma ampla gama de domínios de aplicação:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Desenvolvimento Web: é amplamente usado no desenvolvimento web com frameworks como Django, Flask, Pyramid e muitos outros;

\item {} 
\sphinxAtStartPar
Ciência de dados: Com bibliotecas como Pandas para manipulação de dados, Matplotlib e Seaborn para visualização de dados, e Numpy para computação numérica, Python oferece um ambiente robusto para análise de dados;

\item {} 
\sphinxAtStartPar
Aprendizado de máquina e Inteligência Artificial: pode ser considerada a linguagem predominante na área de aprendizado de máquina e da IA. Bibliotecas como Scikit\sphinxhyphen{}learn, TensorFlow e PyTorch fornecem as ferramentas necessárias para a construção de modelos complexos de aprendizado de máquina e redes neurais;

\item {} 
\sphinxAtStartPar
Automação e Scripting: Devido à sua simplicidade e facilidade de aprendizado, Python é frequentemente a escolha para tarefas de automação e scripting. Python pode ser usado para automatizar tarefas repetitivas, como mover arquivos, fazer scraping de websites ou enviar e\sphinxhyphen{}mails automáticos;

\item {} 
\sphinxAtStartPar
Computação científica e engenharia: Com bibliotecas como Scipy e Numpy, Python é usado em áreas como física, engenharia, bioinformática em tarefas relacionadas à modelagem, simulação e análise de dados;

\item {} 
\sphinxAtStartPar
Teste de software: é frequentemente usado para automação de testes de software devido à sua sintaxe simples e clara e à disponibilidade de bibliotecas de teste, como PyTest e Selenium;

\item {} 
\sphinxAtStartPar
Desenvolvimento de jogos: Bibliotecas como Pygame fornecem os módulos necessários para a criação de jogos;

\item {} 
\sphinxAtStartPar
Geoprocessamento: Python tem se destacado na manipulação e análise de dados geoespaciais. Com bibliotecas como Geopandas, é possível gerenciar dados espaciais e executar sofisticadas operações geoespaciais, incluindo projeções e operações geométricas.

\end{itemize}


\subsection{1.2.2 Vantagens e desvantagens do Python}
\label{\detokenize{introducao:vantagens-e-desvantagens-do-python}}
\sphinxAtStartPar
O Python oferece uma série de vantagens significativas que o tornam adequado para uma variedade de aplicações. Entretanto, existem desvantagens que os desenvolvedores devem considerar ao escolher a linguagem para projetos específicos. Dentre elas, é possível citar:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Velocidade: Em comparação com linguagens compiladas como C ou Java, Python, sendo uma linguagem interpretada, pode ser mais lento em certas aplicações;

\item {} 
\sphinxAtStartPar
Consumo de memória: Python pode ser mais exigente em termos de consumo de memória, o que pode ser um desafio para aplicações que precisam de otimização intensiva de recursos;

\item {} 
\sphinxAtStartPar
Desempenho em aplicações móveis: Enquanto Python é versátil em muitos domínios, ainda não é a escolha preferencial para o desenvolvimento de aplicativos móveis nativos;

\item {} 
\sphinxAtStartPar
Acesso a determinadas bibliotecas: Algumas bibliotecas específicas de setores ainda são mais disponíveis ou otimizadas para outras linguagens.

\item {} 
\sphinxAtStartPar
Threading: Devido ao Global Interpreter Lock (GIL) em CPython (a implementação padrão de Python), Python pode não ser ideal para tarefas que necessitam de multitarefa real utilizando múltiplos núcleos de CPU.

\end{itemize}


\section{1.3 Python aplicado ao Geoprocessamento}
\label{\detokenize{introducao:python-aplicado-ao-geoprocessamento}}
\sphinxAtStartPar
O Python é uma das linguagens de programação mais populares para análise geoespacial atualmente, consolidando\sphinxhyphen{}se como uma ferramenta primordial no campo do geoprocessamento, em parte, graças à sua simplicidade, legibilidade e conjunto de bibliotecas especializadas. Essa linguagem vem contribuindo com a flexibilização e a automatização de tarefas relacionadas a manipulação, a análise e a visualização de dados geoespaciais.

\sphinxAtStartPar
Um dos principais motivos da popularidade do Python no geoprocessamento é sua capacidade de se integrar com várias ferramentas e bibliotecas geoespaciais. Softwares como ArcGIS, QGIS e GRASS, adotaram o Python como sua linguagem de script oficial, permitindo aos usuários automatizar tarefas, desenvolver plugins personalizados e estender a funcionalidade dessas plataformas. Também não é por acaso que GDAL, OGR, PROJ, CGAL, JTS e GEOS possuem integração com o Python. Ao oferecer a integração, essas bibliotecas se tornam mais acessíveis, permitindo que sejam criadas soluções personalizadas sem precisar fazer uso de linguagens de programação de baixo nível.

\sphinxAtStartPar
A comunidade Python também contribuiu para a popularidade da linguagem no geoprocessamento com a criação de bibliotecas como Geopandas, Shapely e Pyproj. Estas bibliotecas facilitam a análise e a manipulação de dados geoespaciais diretamente no ambiente Python, unindo as capacidades geoespaciais com o ecossistema de bibliotecas de ciência de dados disponíveis, como Pandas e Numpy. Além disso, a capacidade do Python de se integrar com tecnologias web abriu portas para a criação de aplicações geoespaciais interativas. Bibliotecas como Folium e GeoDjango tornam mais fácil desenvolver soluções web baseadas em mapas interativos e bancos de dados geoespaciais.

\sphinxAtStartPar
Em síntese, a área do geoprocessamento vem sendo profundamente influenciada pelo Python. A flexibilidade da linguagem, combinada com sua ampla gama de bibliotecas e compatibilidade com ferramentas geoespaciais proeminentes a estabeleceu como uma escolha natural no setor. No contexto atual, onde os dados desempenham um papel central, o domínio em Python se revela uma habilidade valiosa para qualquer profissional que atue ou deseje atuar na área do geoprocessamento.


\subsection{1.3.1 Ecossistema Python em geoprocessamento}
\label{\detokenize{introducao:ecossistema-python-em-geoprocessamento}}
\sphinxAtStartPar
Especificamente para o contexto do Geoprocessamento, o Python oferece um conjunto de ferramentas que permitem lidar com uma ampla variedade de tarefas, desde a manipulação e análise de dados geoespaciais até a visualização e integração com sistemas de SIG. Vamos explorar este ecossistema em mais detalhe:

\sphinxAtStartPar
\sphinxstyleemphasis{Manipulação e Análise de Dados Vetoriais:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Geopandas: Extensão do Pandas para a manipulação de dados geoespaciais. Permite trabalhar com dados espaciais de forma semelhante a como os dados tabulares são manipulados com o Pandas. Usa Fiona para ler e escrever dados. Armazena geometrias como objetos shapely. Inclui funções para análises geospaciais. Recursos para plotagem básica.

\item {} 
\sphinxAtStartPar
Shapely: Fornece operações e manipulações de geometria planar. É a base da manipulação geométrica em muitas outras bibliotecas.

\item {} 
\sphinxAtStartPar
Fiona: Para leitura e escrita de dados vetoriais (similar ao GDAL, mas com uma interface mais “pythonica”).

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{Manipulação e Análise de Dados matriciais:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Rasterio: Facilita a leitura, escrita e manipulação de dados raster. É uma interface Python para o GDAL para trabalhar com dados no Numpy.

\item {} 
\sphinxAtStartPar
Pyproj: Fornece interfaces Python para PROJ, que é uma biblioteca usada para transformações entre sistemas de coordenadas geográficas.

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{Funções de Processamento Geoespacial:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
GDAL (Geospatial Data Abstraction Library): É uma biblioteca de baixo nível para ler e escrever formatos de dados espaciais, e inclui muitas utilidades para transformação e processamento.

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{Estatísticas Espaciais e Análise Avançada:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
PySAL (Python Spatial Analysis Library): Oferece uma suíte de ferramentas para análise espacial, incluindo estatísticas espaciais, econometria espacial e visualização.

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{Visualização:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
mplleaflet é uma extensão que converte gráficos Matplotlib em visualizações de mapas interativos usando Leaflet.

\item {} 
\sphinxAtStartPar
Folium: Biblioteca que facilita a visualização de dados em um mapa interativo baseado em Leaflet.

\item {} 
\sphinxAtStartPar
GeoViews é construído sobre Bokeh e HoloViews para oferecer visualizações geoespaciais fáceis e interativas.

\item {} 
\sphinxAtStartPar
ipyleaflet: Uma extensão interativa do Jupyter para a visualização de mapas baseada na biblioteca Leaflet. É excelente para análise geoespacial em Notebooks Jupyter.

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{Integração com Sistemas GIS:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
ArcPy: Módulo Python do software ArcGIS que permite a automação de tarefas e a extensão das funcionalidades do ArcGIS usando Python.

\item {} 
\sphinxAtStartPar
QGIS Python API (PyQGIS): Permite automação e extensão das funcionalidades do QGIS usando Python.

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{Desenvolvimento Web e Bancos de Dados Espaciais:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
GeoDjango: Um módulo do framework web Django que facilita a criação de aplicações web geoespaciais.

\item {} 
\sphinxAtStartPar
GeoAlchemy: Extensão do SQLAlchemy para trabalhar com bancos de dados espaciais.

\item {} 
\sphinxAtStartPar
PostGIS: Extensão espacial para PostgreSQL que permite o armazenamento e a manipulação de informações geográficas.

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{Outras Ferramentas e Bibliotecas:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Cartopy: Usado para mapeamento e projeções geográficas, particularmente útil para visualização de dados em mapas.

\item {} 
\sphinxAtStartPar
OWSLib: Para interagir com serviços web geoespaciais.

\item {} 
\sphinxAtStartPar
Geopy: Para geocodificação, geolocalização e outras tarefas relacionadas.

\end{itemize}

\sphinxAtStartPar
Além dessas bibliotecas específicas, bibliotecas comumente usadas no dia a dia do geoprocessamento são:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Numpy: É a base para operações numéricas em Python. Ele oferece suporte para arrays multidimensionais, matrizes e funções matemáticas para realizar operações sobre essas estruturas.

\item {} 
\sphinxAtStartPar
Pandas: biblioteca de alta performance que oferece estruturas de dados flexíveis (como o DataFrame) para facilitar a manipulação e análise de dados. Com Pandas, é possível limpar, transformar, agregar e filtrar dados de maneira eficiente.

\item {} 
\sphinxAtStartPar
Matplotlib: A principal biblioteca para visualização em Python, permite criar uma ampla variedade de gráficos estáticos, animados e interativos.

\item {} 
\sphinxAtStartPar
Seaborn: Construído em cima do Matplotlib, foca em visualizações estatísticas mais atraentes e informativas.

\item {} 
\sphinxAtStartPar
Bokeh e Plotly: Oferecem visualizações interativas e são ideais para criar dashboards e aplicações web.

\end{itemize}

\sphinxAtStartPar
Essas bibliotecas fornecem uma base sólida para trabalhar com dados geoespaciais em Python, desde a leitura e escrita de formatos específicos até operações de análise espacial e visualização. No entanto, estas são apenas algumas das muitas bibliotecas Python para geoprocessamento. A biblioteca certa para um determinado trabalho dependerá de suas necessidades específicas. Por fim, cabe ressaltar que é importante sempre verificar se existem atualizações ou novas bibliotecas disponíveis para geoprocessamento, pois o ecossistema Python está em constante evolução.


\section{1.4 IDEs e Ambientes de desenvolvimento}
\label{\detokenize{introducao:ides-e-ambientes-de-desenvolvimento}}
\sphinxAtStartPar
As IDEs (Integrated Development Environments) e ambientes de desenvolvimento em Python são fundamentais para facilitar e otimizar o fluxo de trabalho dos desenvolvedores. Essas plataformas oferecem um conjunto integrado de ferramentas que auxiliam desde a escrita do código, com recursos como realce de sintaxe e autocompletar, até a depuração e teste de aplicações. Ao longo dos anos, a comunidade Python desenvolveu e aprimorou uma variedade de IDEs e ambientes, cada um com suas peculiaridades e vantagens, atendendo a diferentes necessidades e estilos de programação. Escolher o ambiente certo pode significativamente o desenvolvimento e melhorar a qualidade do código produzido. A seguir, exploraremos alguns dos ambientes e ferramentas mais populares usados para trabalhar com Python.

\sphinxAtStartPar
Ambiente de Linha de Comando (CLI):
\begin{itemize}
\item {} 
\sphinxAtStartPar
Terminal Python (Python Shell): Este é o REPL (Read\sphinxhyphen{}Eval\sphinxhyphen{}Print Loop) padrão do Python, acessível digitando python ou python3 no terminal ou prompt de comando.

\item {} 
\sphinxAtStartPar
IPython: versão aprimorada do terminal Python padrão, oferecendo recursos como auto\sphinxhyphen{}completar, histórico avançado e capacidade de visualização.

\end{itemize}

\sphinxAtStartPar
Jupyter e Ambientes Relacionados:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Jupyter Notebook: plataforma de desenvolvimento integrado (IDE) que une a edição de código à visualização imediata de seus resultados.

\item {} 
\sphinxAtStartPar
JupyterLab: interface de usuário baseada na web que fornece uma extensão do Jupyter Notebook, com uma área de trabalho mais flexível e recursos adicionais.

\item {} 
\sphinxAtStartPar
Google Colab: Baseado no Jupyter Notebook, é uma plataforma de notebooks oferecida pelo Google com GPU gratuita e integração com o Google Drive. Será utilizado para o desenvolvimento de nosso curso.

\end{itemize}

\sphinxAtStartPar
Ambientes de Desenvolvimento Integrado (IDEs):
\begin{itemize}
\item {} 
\sphinxAtStartPar
PyCharm: IDE popular da JetBrains específico para Python, com recursos avançados como depuração, testes unitários e integração com sistemas de controle de versão.

\item {} 
\sphinxAtStartPar
Visual Studio Code (VS Code): editor de código leve, mas poderoso da Microsoft com suporte ao Python através de extensões. Ele possui recursos como depuração, linting e Git integrado.

\item {} 
\sphinxAtStartPar
Spyder: IDE com foco em análise de dados, frequentemente comparada ao MATLAB ou RStudio, mas para Python.

\end{itemize}

\sphinxAtStartPar
Ambientes Virtuais e Gerenciadores de Pacotes:
\begin{itemize}
\item {} 
\sphinxAtStartPar
venv: ferramenta padrão para criar ambientes virtuais em Python.

\item {} 
\sphinxAtStartPar
virtualenv: ferramenta externa que oferece mais funcionalidades do que o venv.

\item {} 
\sphinxAtStartPar
conda: gerenciador de pacotes e ambiente, frequentemente associado à distribuição Anaconda. É particularmente útil para ciência de dados e projetos que necessitam de bibliotecas não\sphinxhyphen{}Python.

\end{itemize}

\sphinxAtStartPar
Editores de Texto com Suporte ao Python:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Sublime Text: editor de texto rápido e altamente personalizável com um pacote chamado “Anaconda” (não confundir com a distribuição de Python) que fornece funcionalidade IDE\sphinxhyphen{}like para Python.

\item {} 
\sphinxAtStartPar
Atom: editor de texto open\sphinxhyphen{}source desenvolvido pelo GitHub que pode ser transformado em um ambiente Python completo através de pacotes e extensões.

\end{itemize}

\sphinxAtStartPar
Outros IDEs:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Eclipse com PyDev: IDE popular para várias linguagens, e PyDev é um plugin que adiciona suporte para desenvolvimento Python.

\item {} 
\sphinxAtStartPar
Thonny: IDE para iniciantes, focado em ensinar programação em Python.

\end{itemize}

\sphinxAtStartPar
A escolha de um ambiente específico frequentemente se resume a preferências pessoais, natureza do projeto e experiência anterior. Em muitos casos, é comum utilizar mais de um ambiente e/ou ferramenta.

\sphinxAtStartPar
\sphinxstyleemphasis{O Jupyter Notebook e o Google Colaboratory}

\sphinxAtStartPar
O Jupyter Notebook é uma plataforma de desenvolvimento integrado (IDE) que une a edição de código à visualização imediata de seus resultados. Esta ferramenta facilita a elaboração de documentos interativos, incorporando não só códigos, mas também textos estilizados, imagens, diagramas e fórmulas matemáticas. Sua capacidade de compartilhamento promove a cooperação entre diversos usuários em um único documento, seja por meio de repositórios no GitHub ou pelo serviço online Jupyter Notebook Viewer. É uma ferramenta popular entre cientistas de dados, pesquisadores e educadores para realizar análises de dados, modelagem estatística, simulação numérica, ensino de programação, entre outros.
Algumas das principais características e funcionalidades do Jupyter Notebook:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Código Interativo: Uma de suas principais características é a capacidade de executar código de forma interativa. Isto é, você pode escrever e executar o código em células individuais e ver os resultados imediatamente, facilitando a experimentação e a depuração.

\item {} 
\sphinxAtStartPar
Suporte a Múltiplas Linguagens: Embora o nome Jupyter derive de Julia, Python e R (as três linguagens de programação iniciais suportadas pelo Jupyter), atualmente, o notebook suporta muitas outras linguagens, incluindo Java, C++, Ruby, entre outras, por meio de kernels específicos para cada linguagem;

\item {} 
\sphinxAtStartPar
Visualização de Dados: O Jupyter Notebook se integra bem com várias bibliotecas de visualização, como Matplotlib, Seaborn e Bokeh, permitindo que os usuários criem gráficos e visualizações interativas diretamente no notebook;

\item {} 
\sphinxAtStartPar
Integração com LaTeX: Para quem trabalha com matemática ou ciências, o Jupyter Notebook oferece suporte à notação LaTeX, facilitando a escrita de equações matemáticas complexas;

\item {} 
\sphinxAtStartPar
Extensibilidade: O Jupyter Notebook é extensível e pode ser personalizado para atender às necessidades específicas dos usuários. Existem muitos plugins e extensões disponíveis que adicionam funcionalidades ao ambiente.

\item {} 
\sphinxAtStartPar
Exportação e Compartilhamento: Os notebooks podem ser exportados para vários formatos, incluindo HTML, PDF, Markdown e slides. Isso facilita o compartilhamento de análises, resultados e documentação com outras pessoas.

\item {} 
\sphinxAtStartPar
Integração com Ferramentas de Ciência de Dados: O Jupyter Notebook se integra facilmente com bibliotecas e ferramentas populares de ciência de dados, como Pandas, Numpy, Scikit\sphinxhyphen{}learn e TensorFlow, tornando\sphinxhyphen{}o uma ferramenta central em muitos workflows de análise de dados.

\item {} 
\sphinxAtStartPar
Interface com Outras Ferramentas: Além do tradicional formato de notebook, o projeto Jupyter também oferece o JupyterLab, uma interface de usuário mais avançada que oferece uma experiência semelhante a uma IDE, com múltiplas janelas e painéis.

\item {} 
\sphinxAtStartPar
Reprodutibilidade: Ao detalhar cada etapa da análise, os notebooks promovem práticas de ciência reprodutível. Outros pesquisadores ou colegas podem seguir o mesmo processo, entender as decisões tomadas e até reproduzir os resultados.

\item {} 
\sphinxAtStartPar
Integração com Big Data: O Jupyter pode ser integrado com plataformas de big data como Apache Spark, permitindo análises em grandes conjuntos de dados diretamente a partir do notebook.

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{Google Colaboratory}

\sphinxAtStartPar
O Google Colaboratory, conhecido como “Google Colab”, é um serviço gratuito do Google que oferece um ambiente Jupyter Notebook na nuvem. Ele permite desenvolver, executar e compartilhar códigos em Python diretamente pelo navegador, sem necessidade de configuração prévia. Essa facilidade torna o Colab atraente para iniciantes em análise de dados e geoprocessamento, assim como para pesquisadores e desenvolvedores interessados em colaboração e experimentação rápida.

\sphinxAtStartPar
A interface do Colab é intuitiva, muito similar à do Jupyter Notebook tradicional. No entanto, ela vem com integrações adicionais, como o Google Drive, garantindo que os notebooks sejam salvos automaticamente em sua conta e possam ser compartilhados como qualquer outro documento Google.
Uma das maiores vantagens do Google Colab é seu acesso à infraestrutura robusta do Google Cloud. Isso permite que os usuários se beneficiem de recursos computacionais avançados, como GPUs e TPUs, ideais para tarefas intensivas que poderiam ser desafiadoras para computadores pessoais convencionais.

\sphinxstepscope


\chapter{2. FUNDAMENTOS DA LINGUAGEM PYTHON}
\label{\detokenize{capitulo2:fundamentos-da-linguagem-python}}\label{\detokenize{capitulo2::doc}}

\section{2.1 Sintaxe básica: variáveis, operadores, expressões}
\label{\detokenize{capitulo2:sintaxe-basica-variaveis-operadores-expressoes}}
\sphinxAtStartPar
O entendimento da sintaxe básica do Python é fundamental para começar a programar nesta linguagem, especialmente em aplicações voltadas para o geoprocessamento. Nesta seção abordaremos três elementos essenciais da sintaxe do Python: variáveis, operadores e expressões.


\subsection{2.1.1 Variáveis}
\label{\detokenize{capitulo2:variaveis}}
\sphinxAtStartPar
Em Python, as variáveis são usadas para armazenar informações que podem ser referenciadas e manipuladas em um programa. A atribuição de valores a variáveis em Python é feita usando o operador “=”, e não é necessário declarar explicitamente o tipo da variável, já que Python é uma linguagem de tipagem dinâmica. São exemplos de variáveis:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{8}
\PYG{n}{nome} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Airton}\PYG{l+s+s1}{\PYGZsq{}}      
\PYG{n}{idade} \PYG{o}{=} \PYG{l+m+mi}{30}              
\PYG{n}{altura\PYGZus{}metros} \PYG{o}{=} \PYG{l+m+mf}{1.75}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Tipagem dinâmica refere\sphinxhyphen{}se ao mecanismo pelo qual o tipo de uma variável é determinado em tempo de execução, ao contrário da tipagem estática, onde o tipo de uma variável é determinado em tempo de compilação. Em linguagens com tipagem dinâmica, o tipo de uma variável pode mudar durante a execução do programa, dependendo do valor que lhe é atribuído.
Cada linguagem de programação possui suas próprias regras e convenções para nomear variáveis, mas existem algumas práticas gerais recomendadas:

\sphinxAtStartPar
Regras comuns:
O nome geralmente começa com uma letra ou sublinhado (\_);
Pode conter letras (maiúsculas ou minúsculas), números ou sublinhados;
Não deve conter espaços ou caracteres especiais;
Não deve ser uma palavra reservada da linguagem.

\sphinxAtStartPar
Convenções (de acordo com PEP 8)
O PEP 8 é a convenção de estilo para o código Python. PEP é uma sigla para “Python Enhancement Proposal” (Proposta de Melhoria do Python), e o número 8 refere\sphinxhyphen{}se ao número específico deste PEP. O PEP 8 fornece um conjunto de regras e recomendações para formatar o código Python, tornando\sphinxhyphen{}o mais legível e consistente em toda a comunidade Python.

\sphinxAtStartPar
Nomes de Variáveis: devem ser escritos em letras minúsculas, com palavras separadas por sublinhados. Exemplo: minha\_variavel, contador, taxa\_de\_juros;
Variáveis Privadas: Para variáveis que são destinadas a uso interno dentro de um módulo ou classe e que não devem ser acessadas diretamente de fora, é comum usar um sublinhado antes do nome, como \_variavel\_privada;
Variáveis Muito Privadas: Se um nome de variável começa com dois sublinhados \_\_, indica que a variável é “muito privada” e, geralmente, é usada para evitar conflitos de nome em subclasses;
Variáveis de Sistema: Se um nome de variável termina com dois sublinhados, é uma variável de sistema ou “mágica” que tem um uso especial em Python, como \sphinxstylestrong{init}, \sphinxstylestrong{name}, etc;
Constantes: Constantes são geralmente declaradas em letras maiúsculas com palavras separadas por sublinhados, por exemplo: PI, TAXA\_FIXA;
Evitar o Uso de l (letra ‘el’ minúscula) e O (letra ‘o’ maiúscula): Estes podem ser confundidos com o número 1 e 0, respectivamente.

\sphinxAtStartPar
Atribuição de valores a variáveis
Atribuição de valores a variáveis é o processo de guardar um valor em uma variável. Em muitas linguagens de programação, incluindo Python, o operador de atribuição é o sinal de igual (=). Isso significa que você está associando um valor à variável à esquerda do sinal de igual.
Em Python, a operação de atribuição cria uma referência entre o nome da variável e o valor ou objeto. Portanto, a variável não contém o valor em si, mas sim uma referência para o valor.

\sphinxAtStartPar
Atribuição simples
A atribuição simples é o método mais básico e direto de associar um valor a uma variável. Na atribuição simples, utilizamos o operador “=” para designar um valor a uma variável.

\sphinxAtStartPar
A sintaxe básica é:
nome\_da\_variavel = valor

\sphinxAtStartPar
Aqui estão alguns exemplos usando Python:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{15}             \PYG{c+c1}{\PYGZsh{} Atribui o valor inteiro 15 à variável x}
\PYG{n}{altura} \PYG{o}{=} \PYG{l+m+mf}{1.80}      \PYG{c+c1}{\PYGZsh{} Atribui o valor real 1.80 à variável altura}
\PYG{n}{nome} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Julia}\PYG{l+s+s1}{\PYGZsq{}}     \PYG{c+c1}{\PYGZsh{} Atribui a string \PYGZsq{}Julia\PYGZsq{} à variável nome}
\PYG{n}{ativo} \PYG{o}{=} \PYG{k+kc}{True}       \PYG{c+c1}{\PYGZsh{} Atribui o valor booleano True (verdadeiro) à variável ativo}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Em linguagens com tipagem dinâmica, como Python, o tipo da variável é determinado automaticamente com base no valor atribuído. Assim, você não precisa declarar explicitamente o tipo da variável ao criá\sphinxhyphen{}la.
A principal coisa a lembrar sobre a atribuição simples é que ela designa um valor à variável, e a variável passa a referenciar esse valor. Se o valor for um objeto, a variável não contém o objeto em si, mas sim uma referência a ele.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{nome} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Airton}\PYG{l+s+s1}{\PYGZsq{}}            \PYG{c+c1}{\PYGZsh{} A variável \PYGZsq{}nome\PYGZsq{} recebe o valor \PYGZsq{}Airton\PYGZsq{}.}
\PYG{n}{idade} \PYG{o}{=} \PYG{l+m+mi}{30}                 \PYG{c+c1}{\PYGZsh{} A variável \PYGZsq{}idade\PYGZsq{} recebe o valor \PYGZsq{}30\PYGZsq{}.}
\PYG{n}{altura\PYGZus{}metros} \PYG{o}{=} \PYG{l+m+mf}{1.75}       \PYG{c+c1}{\PYGZsh{} A variável \PYGZsq{}altura\PYGZus{}metros\PYGZsq{} recebe o valor \PYGZsq{}1.75\PYGZsq{}.}
\PYG{n}{estudante} \PYG{o}{=} \PYG{k+kc}{True}           \PYG{c+c1}{\PYGZsh{} A variável \PYGZsq{}estudante\PYGZsq{} recebe o valor \PYGZsq{}True\PYGZsq{}.}
\PYG{n}{notas} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{90}\PYG{p}{,} \PYG{l+m+mi}{85}\PYG{p}{,} \PYG{l+m+mi}{88}\PYG{p}{,} \PYG{l+m+mi}{76}\PYG{p}{]}   \PYG{c+c1}{\PYGZsh{} A variável \PYGZsq{}notas\PYGZsq{} recebe a lista de valores \PYGZsq{}[90, 85, 88, 76]\PYGZsq{}.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Uma vez que uma variável é nomeada, seu nome não pode ser alterado. No entanto, o valor associado a essa variável pode.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{10}  \PYG{c+c1}{\PYGZsh{} A variável \PYGZsq{}x\PYGZsq{} recebe o valor 10.}
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{20}  \PYG{c+c1}{\PYGZsh{} O valor de \PYGZsq{}x\PYGZsq{} é alterado para 20, mas seu nome permanece \PYGZsq{}x\PYGZsq{}.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Atribuição múltipla
A atribuição múltipla é uma característica disponível em algumas linguagens de programação, incluindo o Python, que permite que você atribua valores a várias variáveis simultaneamente em uma única instrução. Vamos ver como a atribuição múltipla funciona em Python:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z} \PYG{o}{=} \PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+m+mi}{35}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Neste caso, x receberá o valor 15, y receberá o valor 25, e z receberá o valor 35.
Uma das vantagens da atribuição múltipla é a facilidade com que você pode trocar valores entre duas variáveis.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{7}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{12}
\PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{y}\PYG{p}{,} \PYG{n}{x}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Após a execução dessas instruções, x terá o valor 12 e y terá o valor 7.
A atribuição múltipla torna o código mais conciso e, em muitos casos, mais legível, especialmente quando usada de maneira apropriada e não excessiva.

\sphinxAtStartPar
2.1.2 Operadores: aritméticos, comparação, lógicos

\sphinxAtStartPar
Operadores aritméticos
Os operadores aritméticos são usados em Python para realizar operações matemáticas entre valores ou variáveis. Eles são fundamentais em qualquer linguagem de programação e formam a base para cálculos numéricos. O quadro 1 traz os principais operadores aritméticos em Python.

\sphinxAtStartPar
Adição

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{7}\PYG{o}{+}\PYG{l+m+mi}{4}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
11
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Subtração

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{7}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
3
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Multiplicação

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{7}\PYG{o}{*}\PYG{l+m+mi}{4}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
28
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Divisão

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{9}\PYG{o}{/}\PYG{l+m+mi}{4}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
2.25
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Divisão inteira

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{9}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{4}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
2
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Módulo

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{9}\PYG{o}{\PYGZpc{}}\PYG{k}{4}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
1
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Exponenciação

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{7}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{4}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
2401
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Radiciação

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{9}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{0.5}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
3.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
É importante notar que a ordem das operações segue a precedência matemática padrão. Por exemplo, a multiplicação e a divisão são avaliadas antes da adição e subtração. Se desejar modificar a ordem das operações, pode usar parênteses. Por

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{5} \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{2}  
\PYG{l+m+mi}{5} \PYG{o}{+} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{l+m+mi}{2}    
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
11
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Operadores de comparação
Os operadores de comparação em Python são usados para comparar dois valores e retornar um valor booleano (True ou False) com base no resultado da comparação. Eles são fundamentais para estruturas de controle condicional, como instruções if, elif e else. O quadro 2 traz os principais operadores de comparação em Python.

\sphinxAtStartPar
Operador: Igual a

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{6}\PYG{o}{==}\PYG{l+m+mi}{6}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Operador: Diferente de

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{6}\PYG{o}{!=}\PYG{l+m+mi}{6}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
False
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Operador: Menor que

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{5}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Operador: Maior que

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{5}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{6}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
False
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Operador: Menor ou igual a

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{6}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{6}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Operador: Maior ou igual a

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{6}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{8}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
False
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Operadores lógicos
Os operadores lógicos são usados para avaliar múltiplas condições ou combinar o resultado de diferentes comparações, resultando em um valor booleano (True ou False). O quadro 3 traz os operadores lógicos em Python.

\sphinxAtStartPar
Operador and: Retorna True se ambas as condições forem verdadeiras.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{idadeLuiza} \PYG{o}{=} \PYG{l+m+mi}{19}
\PYG{n}{idadePietra} \PYG{o}{=} \PYG{l+m+mi}{14}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Operador or: Retorna True se pelo menos uma das condições for verdadeira.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{idadeLuiza} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{18} \PYG{o+ow}{and} \PYG{n}{idadePietra} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{18} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
False
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Operador not: Inverte o valor booleano.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{idadeLuiza} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{18} \PYG{o+ow}{or} \PYG{n}{idadePietra} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{18}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Esses operadores são essenciais para controle de fluxo em programação, permitindo combinações complexas de condições em estruturas como if, while, entre outras. A capacidade de avaliar e combinar condições é uma parte fundamental da lógica de programação. No decorrer de nosso curso, aprofundaremos nosso estudo sobre os operadores, contemplando ainda os operadores de atribuição, de identidade e de associação.

\sphinxAtStartPar
2.1.3 Expressões

\sphinxAtStartPar
Expressões em Python referem\sphinxhyphen{}se a combinações de valores, variáveis e operadores que são avaliadas pelo interpretador Python para produzir um resultado. Em termos simples, uma expressão é como uma instrução matemática que o Python resolve e retorna um valor. No contexto de uma expressão:

\sphinxAtStartPar
Valores: São os dados básicos com os quais trabalhamos, como números (2, 4.5) ou strings (“geoprocessamento”, “Python”).
Operadores: São símbolos que realizam operações sobre valores, como adição (“+”), subtração (“\sphinxhyphen{}”), multiplicação (“*”), divisão (“/”) e muitos outros.
Exemplo: “3 + 4” é uma expressão onde “3” e “4” são valores e “+” é um operador.

\sphinxAtStartPar
Variáveis: São nomes que designam locais na memória para armazenar valores. Uma vez que um valor é atribuído a uma variável, a variável pode ser usada em expressões.
Exemplo: “x = 5” (Aqui, “x” é uma variável e “5” é um valor. Depois disso, é possível usar “x” em expressões como “x + 2”.)

\sphinxAtStartPar
Funções: são blocos de código reutilizáveis que realizam uma tarefa específica. Em expressões, funções podem ser usadas para processar valores e produzir resultados.
Exemplo: “print(“Geoprocessamento com Python”)” (Aqui, “print” é uma função que exibe seu argumento.)

\sphinxAtStartPar
Avaliação: Quando o Python encontra uma expressão, seja em um script ou no terminal interativo, ele avalia (ou calcula) a expressão e retorna um resultado.
Exemplo: Na expressão “7 * 6”, o Python avaliará isso e retornará “42”.

\sphinxAtStartPar
Tipos básicos de dados

\sphinxAtStartPar
Os tipos básicos de dados (figura 1), também conhecidos como tipos primitivos ou fundamentais, referem\sphinxhyphen{}se às categorias mais simples e fundamentais de informações que uma linguagem de programação pode representar e manipular diretamente. Em Python, os principais tipos básicos de dados são: Inteiros, Ponto Flutuante, Strings, Booleanos e Bytes. Esses tipos de dados são a base para a representação e manipulação de informações em Python. O entendimento desses tipos básicos é essencial, pois eles são frequentemente usados em combinação com as estruturas mais avançadas.

\sphinxAtStartPar
Figura 1: Tipos básicos de dados em Python.

\sphinxAtStartPar
2.2.1 Inteiros
Inteiros são números sem uma parte fracionária, podendo ser positivos, negativos ou zero. Eles são fundamentais na matemática e na ciência da computação e são um dos tipos de dados primitivos mais comuns em linguagens de programação. Em Python, o tipo para inteiros é int.

\sphinxAtStartPar
Características dos Inteiros:
Natureza: não têm uma parte decimal. Podem ser tanto números positivos quanto negativos, incluindo o zero;
Operações Básicas: Com inteiros, você pode realizar operações aritméticas padrão como adição, subtração, multiplicação e divisão (embora a divisão de dois inteiros, em muitas linguagens de programação modernas, possa resultar em um número de ponto flutuante);
Tamanho e Limites: o tamanho (ou a quantidade de memória ocupada) por um inteiro pode variar, mas há um limite. Em versões recentes do Python, o tamanho dos inteiros é flexível e expande conforme necessário, mas é limitado pela quantidade de memória disponível.

\sphinxAtStartPar
Exemplos:
Definindo inteiros

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{b} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Imprimindo o tipo para confirmar que são inteiros

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}class \PYGZsq{}int\PYGZsq{}\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Operações básicas

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{soma} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}  
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{soma}\PYG{p}{)}   
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
2
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{subtracao} \PYG{o}{=} \PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b}  
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{subtracao}\PYG{p}{)} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
8
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{multiplicacao} \PYG{o}{=} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b}  
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{multiplicacao}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}15
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{divisao} \PYG{o}{=} \PYG{n}{a} \PYG{o}{/} \PYG{n}{b}  
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{divisao}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}1.6666666666666667
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
No último exemplo, embora ambos a e b sejam inteiros, a divisão resulta em um número de ponto flutuante (float) em Python. Se você quiser um resultado inteiro da divisão (descartando a parte fracionária), pode usar o operador de divisão inteira:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{divisao\PYGZus{}inteira} \PYG{o}{=} \PYG{n}{a} \PYG{o}{/}\PYG{o}{/} \PYG{n}{b}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{divisao\PYGZus{}inteira}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}2
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Além disso, Python oferece operadores específicos, como o operador módulo, que retorna o resto da divisão de dois inteiros:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{resto} \PYG{o}{=} \PYG{n}{a} \PYG{o}{\PYGZpc{}} \PYG{n}{b}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{resto}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}1
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
2.2.2 Floats (Números de Ponto Flutuante)

\sphinxAtStartPar
São números que têm uma parte decimal. Eles são usados para representar quantidades que não são inteiras. Em termos técnicos, “ponto flutuante” refere\sphinxhyphen{}se à maneira como estes números são representados internamente e a operações que podem ser realizadas com eles. Em Python, o tipo para números de ponto flutuante é float.
Características dos Floats:
Natureza: Podem representar tanto números fracionários quanto inteiros;
Precisão: Devido à maneira como os floats são armazenados e representados internamente, eles têm uma precisão limitada, o que pode levar a pequenas imprecisões em cálculos;
Operações Básicas: Como os inteiros, os floats também suportam operações aritméticas padrão, como adição, subtração, multiplicação e divisão;
Representação: Em algumas situações, números que parecem ser simples podem ter representações imprecisas quando armazenados como floats. Por exemplo, 0.1 pode não ser armazenado exatamente como 0.1 devido à maneira como os números de ponto flutuante são representados.

\sphinxAtStartPar
Exemplos:
Definindo floats

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mf}{3.14}
\PYG{n}{y} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.001}
\PYG{n}{z} \PYG{o}{=} \PYG{l+m+mf}{2.0} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Imprimindo o tipo para confirmar que são floats

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}class \PYGZsq{}float\PYGZsq{}\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Operações básicas

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{soma} \PYG{o}{=} \PYG{n}{x} \PYG{o}{+} \PYG{n}{y}  
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{soma}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
3.1390000000000002
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{multiplicacao} \PYG{o}{=} \PYG{n}{x} \PYG{o}{*} \PYG{n}{y}  
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{multiplicacao}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: \PYGZhy{}0.00314}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}0.00314
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{divisao} \PYG{o}{=} \PYG{n}{x} \PYG{o}{/} \PYG{n}{z}  
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{divisao}\PYG{p}{)} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.57
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
No contexto de aritmética de ponto flutuante em Python, é importante estar ciente da precisão. Veja o seguinte exemplo:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Saída} \PYG{o}{=} \PYG{l+m+mf}{0.1} \PYG{o}{+} \PYG{l+m+mf}{0.1} \PYG{o}{+} \PYG{l+m+mf}{0.1}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{Saída}\PYG{p}{)}  
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{Saída} \PYG{o}{==} \PYG{l+m+mf}{0.3}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0.30000000000000004
False
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Saída pode ser ‘False’ devido a imprecisões de ponto flutuante

\sphinxAtStartPar
A maneira como os números de ponto flutuante é representada internamente pode levar a essa imprecisão. Em muitos casos, é aconselhável usar uma comparação com alguma “margem de erro” em vez de uma comparação direta:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{epsilon} \PYG{o}{=} \PYG{l+m+mf}{0.00001}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{Saída} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.3}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{epsilon}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Conversão entre tipos numéricos: inteiro e float
Em Python, é comum ser necessário converter valores entre diferentes tipos numéricos, especialmente entre int (números inteiros) e float (números de ponto flutuante). Para converter um número inteiro para um número de ponto flutuante, você pode usar a função float().

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num\PYGZus{}inteiro} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{num\PYGZus{}float} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{num\PYGZus{}inteiro}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{num\PYGZus{}float}\PYG{p}{)} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
5.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Conversão de float para int
Para converter um número de ponto flutuante para um inteiro, você pode usar a função int(). É importante notar que essa conversão simplesmente descarta a parte decimal do número, sem arredondá\sphinxhyphen{}la.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num\PYGZus{}float} \PYG{o}{=} \PYG{l+m+mf}{5.7}
\PYG{n}{num\PYGZus{}inteiro} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{num\PYGZus{}float}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{num\PYGZus{}inteiro}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
5
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Avisos:
Ao converter de float para int, é importante lembrar que a parte decimal é truncada, não arredondada. Assim, 4.9 se tornará 4, e não 5.
A conversão de um número muito grande ou muito pequeno pode resultar em imprecisões. Sempre esteja ciente das limitações da precisão do ponto flutuante ao trabalhar com conversões.
É sempre uma boa prática verificar os valores antes de convertê\sphinxhyphen{}los para evitar erros em tempo de execução.

\sphinxAtStartPar
Em algumas situações, você pode querer arredondar o número de ponto flutuante antes de convertê\sphinxhyphen{}lo para inteiro. Nesse caso, você pode usar a função round() para arredondar ao número inteiro mais próximo.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num\PYGZus{}float1} \PYG{o}{=} \PYG{l+m+mf}{5.7}
\PYG{n}{num\PYGZus{}inteiro1} \PYG{o}{=} \PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{num\PYGZus{}float1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num\PYGZus{}float2} \PYG{o}{=} \PYG{l+m+mf}{5.2}
\PYG{n}{num\PYGZus{}inteiro2} \PYG{o}{=} \PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{num\PYGZus{}float2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{num\PYGZus{}inteiro1}\PYG{p}{)}  
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{num\PYGZus{}inteiro2}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
6
5
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Em Python, a conversão de tipo pode ser feita de maneira implícita, ocorrendo automaticamente pelo interpretador sem a necessidade de ação direta do programador. Quando você realiza uma operação aritmética entre um int e um float, o Python converte automaticamente o int em float.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{inteiro} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{n}{flutuante} \PYG{o}{=} \PYG{l+m+mf}{2.5}
\PYG{n}{Saída} \PYG{o}{=} \PYG{n}{inteiro} \PYG{o}{+} \PYG{n}{flutuante}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{Saída}\PYG{p}{)}  
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{Saída}\PYG{p}{)}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
5.5
\PYGZlt{}class \PYGZsq{}float\PYGZsq{}\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Note que a variável resultado é do tipo float mesmo que apenas um dos operandos fosse originalmente float.

\sphinxAtStartPar
2.2.3 Booleanos

\sphinxAtStartPar
Os booleanos são um tipo de dado que representa uma das duas possíveis verdades: verdadeiro ou falso. Em Python, essas verdades são representadas pelas palavras\sphinxhyphen{}chave True (verdadeiro) e False (falso). O tipo booleano é fundamental em programação, pois muitas decisões e operações lógicas são baseadas em testes que resultam em um valor verdadeiro ou falso. Em Python, o tipo para valores booleanos é bool.

\sphinxAtStartPar
Características dos Booleanos:
Simplicidade: Booleanos só têm dois possíveis valores: True ou False;
Operações Lógicas: Os booleanos são frequentemente usados com operadores lógicos, como and, or, e not, para criar expressões mais complexas;
Comparação: Operadores de comparação, como “==”, “!=”, “<”, “>”, “<=”, e “>=”, frequentemente resultam em valores booleanos.

\sphinxAtStartPar
Exemplos de código:

\sphinxAtStartPar
Definindo booleanos

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{esta\PYGZus{}feliz} \PYG{o}{=} \PYG{k+kc}{True}
\PYG{n}{esta\PYGZus{}triste} \PYG{o}{=} \PYG{k+kc}{False}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Imprimindo o tipo para confirmar que são booleanos

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{esta\PYGZus{}feliz}\PYG{p}{)}\PYG{p}{)} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}class \PYGZsq{}bool\PYGZsq{}\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Operações lógicas

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Saída1} \PYG{o}{=} \PYG{n}{esta\PYGZus{}feliz} \PYG{o+ow}{and} \PYG{n}{esta\PYGZus{}triste}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{Saída1}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: False}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
False
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Saída2} \PYG{o}{=} \PYG{n}{esta\PYGZus{}feliz} \PYG{o+ow}{or} \PYG{n}{esta\PYGZus{}triste}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{Saída2}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Saída3} \PYG{o}{=} \PYG{o+ow}{not} \PYG{n}{esta\PYGZus{}feliz}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{Saída3}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
False
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Usando booleanos em comparações:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{idade} \PYG{o}{=} \PYG{l+m+mi}{25}
\PYG{n}{maior\PYGZus{}de\PYGZus{}idade} \PYG{o}{=} \PYG{n}{idade} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{18}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{maior\PYGZus{}de\PYGZus{}idade}\PYG{p}{)} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Comparações podem ser usadas diretamente em instruções condicionais

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{idade} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{30}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Idade é maior que 30.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Idade é 30 ou menor.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Idade} \PYG{n}{é} \PYG{l+m+mi}{30} \PYG{n}{ou} \PYG{n}{menor}\PYG{o}{.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{  File}\PYG{n+nn}{ \PYGZdq{}/tmp/ipykernel\PYGZus{}18709/2586859006.py\PYGZdq{}}\PYG{g+gt}{, line }\PYG{l+m+mi}{5}
    \PYG{n}{Idade} \PYG{n}{é} \PYG{l+m+mi}{30} \PYG{n}{ou} \PYG{n}{menor}\PYG{o}{.}
          \PYG{o}{\PYGZca{}}
\PYG{n+ne}{SyntaxError}: invalid syntax
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Estudaremos as instruções condicionais mais adiante em nosso curso. Em Python, muitos outros tipos de dados podem ser avaliados em um contexto booleano, significando que eles podem ser tratados como True ou False sob certas condições. Por exemplo:

\sphinxAtStartPar
Valores numéricos 0 (zero) são tratados como False, enquanto outros valores numéricos são tratados como True;
Coleções vazias (como listas, tuplas e strings vazias) são tratadas como False. Coleções não vazias são True;
None é sempre tratado como False.

\sphinxAtStartPar
2.2.4 Bytes

\sphinxAtStartPar
Bytes são sequências imutáveis de inteiros pequenos no intervalo de 0 a 255. Eles são frequentemente usados para representar dados binários, como arquivos de imagem, áudio ou qualquer outro tipo de dado que não seja simplesmente texto. Em Python, dados do tipo byte são essenciais quando lidamos com operações de I/O (entrada e saída), especialmente quando os dados não são representáveis como strings de texto. Em Python, você pode criar bytes usando a sintaxe “b’’ ou com a função bytes().

\sphinxAtStartPar
Características dos Bytes:
Imutabilidade: são imutáveis. Uma vez definidos, seus valores não podem ser alterados;
Representação: são sequências de inteiros (byte literals) que variam de 0 a 255;
Uso comum: Ideal para lidar com dados binários, como operações de I/O, comunicação de rede, arquivos binários, etc.

\sphinxAtStartPar
Exemplos de código:

\sphinxAtStartPar
Criando bytes usando a sintaxe b’’

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dados\PYGZus{}binarios} \PYG{o}{=} \PYG{l+s+sa}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ol}\PYG{l+s+se}{\PYGZbs{}xc3}\PYG{l+s+se}{\PYGZbs{}xa1}\PYG{l+s+s1}{ Mundo}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{dados\PYGZus{}binarios}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Convertendo uma string em bytes

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{string\PYGZus{}normal} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Olá Mundo}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{bytes\PYGZus{}convertidos} \PYG{o}{=} \PYG{n}{string\PYGZus{}normal}\PYG{o}{.}\PYG{n}{encode}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{utf\PYGZhy{}8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{bytes\PYGZus{}convertidos}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Acessando elementos dos bytes (semelhante a listas e strings)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{primeiro\PYGZus{}byte} \PYG{o}{=} \PYG{n}{dados\PYGZus{}binarios}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{primeiro\PYGZus{}byte}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Bytes são imutáveis. A tentativa de mudar um valor resultará em um erro.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} dados\PYGZus{}binarios[0] = 80  }
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Criando bytes a partir de uma lista de inteiros

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{lista\PYGZus{}de\PYGZus{}inteiros} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{65}\PYG{p}{,} \PYG{l+m+mi}{66}\PYG{p}{,} \PYG{l+m+mi}{67}\PYG{p}{]}
\PYG{n}{dados\PYGZus{}binarios2} \PYG{o}{=} \PYG{n+nb}{bytes}\PYG{p}{(}\PYG{n}{lista\PYGZus{}de\PYGZus{}inteiros}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{dados\PYGZus{}binarios2}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Vale mencionar que, além de bytes, Python também oferece o tipo bytearray, que é uma versão mutável dos bytes. Enquanto os valores dentro de um objeto bytes não podem ser modificados após sua criação, os valores dentro de um bytearray podem ser alterados.

\sphinxAtStartPar
2.2.5 Strings

\sphinxAtStartPar
Strings em Python são sequências de caracteres que representam texto. São fundamentais em programação, pois permitem representar e manipular dados textuais, armazenar informações, exibir mensagens ao usuário, entre outras funções. Algumas das características das Strings são:
Imutabilidade: Depois de definida, uma string não pode ter seu conteúdo alterado. Qualquer operação que “modifique” a string, na realidade, cria uma nova string com o conteúdo alterado;
Indexação e fatiamento: Como as strings são sequências, podemos acessar seus caracteres por índices e fatiar sub\sphinxhyphen{}strings;
Métodos integrados: Python fornece muitos métodos úteis para processar e manipular strings.

\sphinxAtStartPar
Definição de Strings com o uso de aspas
Strings podem ser definidas usando aspas simples, aspas duplas ou três aspas duplas (para strings de várias linhas). Todas essas formas são válidas e a escolha entre elas muitas vezes se resume a preferência pessoal ou à necessidade de incluir certos caracteres na string (por exemplo, se você quiser incluir um apóstrofo em uma string, pode ser mais fácil usar aspas duplas para definir a string).

\sphinxAtStartPar
Definindo strings

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{nome} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Python}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{frase} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Aprendendo Python!}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{paragrafo} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{l+s+s1}{Python é uma linguagem de programação}
\PYG{l+s+s1}{importante no contexto do Geoprocessamento.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Imprimindo strings

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{nome}\PYG{p}{)}        
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{frase}\PYG{p}{)}      
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{paragrafo}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Indexação de Strings
Em Python, strings são sequências de caracteres. Cada caractere em uma string tem um índice associado a ele, começando em 0 para o primeiro caractere, 1 para o segundo, e assim por diante. Isso permite que você acesse caracteres específicos em uma string usando seu índice. Na figura 2, temos a string “Python” com sua indexação.

\sphinxAtStartPar
Figura 2: Índice da string Python.

\sphinxAtStartPar
Aqui estão algumas questões básicas relacionadas ao acesso de string por índice:

\sphinxAtStartPar
Acessar um Caractere Específico

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{nome} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Python}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{nome}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}  
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{nome}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Índices Negativos: Python suporta índices negativos, o que significa começar a contar a partir do final da string.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{nome}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}  
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{nome}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Limites de Índice: Se você tentar acessar um índice que está fora da faixa da string, você receberá um erro IndexError.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{nome}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Resultará em um erro, pois o índice 6 está fora da faixa.

\sphinxAtStartPar
Fatiamento de Strings: Além de acessar caracteres individuais, você também pode acessar subconjuntos ou “fatias” de uma string usando o conceito de fatiamento.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{nome}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Imutabilidade de Strings
Como vimos anteriormente, strings são consideradas objetos imutáveis em Python. Isso significa que, uma vez que uma string é criada, você não pode modificar diretamente seu conteúdo. Se você tentar reatribuir um valor a uma posição específica da string, você receberá um erro. Por exemplo, se você tentar alterar o primeiro caractere de nome para ‘C’, você receberá um TypeError, indicando que a operação não é permitida.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{nome}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Concatenação de strings
Concatenação é o processo de combinar duas ou mais strings para formar uma única string. Em Python, o operador “+” é usado para concatenar strings. Isso significa que ele combina as strings fornecidas para formar uma nova string.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{nome} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Python}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{mensagem} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Olá, }\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{nome} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{mensagem}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Interpolação de Strings
A interpolação de strings, particularmente usando f\sphinxhyphen{}strings (introduzida no Python 3.6), é uma maneira eficiente e legível de formatar strings. Ela permite que você incorpore expressões diretamente dentro de strings literais, usando \{\}. Os benefícios das f\sphinxhyphen{}strings incluem:

\sphinxAtStartPar
Legibilidade: tornam o código mais legível, especialmente quando você tem múltiplas variáveis ou expressões a serem interpoladas em uma string;
Performance: geralmente oferecem uma performance melhor em comparação com outras técnicas de formatação de string em Python;
Flexibilidade: Você pode incorporar qualquer expressão válida do Python dentro das chaves \{\}, o que torna as f\sphinxhyphen{}strings versáteis.

\sphinxAtStartPar
Exemplo:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
valor\PYGZus{}venda = 30
mensagem\PYGZus{}venda = f\PYGZsq{}O valor total da compra foi R\PYGZdl{} \PYGZob{}valor\PYGZus{}venda\PYGZcb{}.\PYGZsq{}
print(mensagem\PYGZus{}venda)  ```


Nesse código:
Definimos uma variável valor\PYGZus{}venda com o valor 30;
Criamos uma f\PYGZhy{}string “mensagem\PYGZus{}venda” onde incorporamos a variável “valor\PYGZus{}venda” diretamente dentro da string usando chaves \PYGZob{}\PYGZcb{}. Isso significa que o valor de “valor\PYGZus{}venda” será inserido na posição onde \PYGZob{}valor\PYGZus{}venda\PYGZcb{} está na string;
Usando a função print(), imprimimos o valor da variável “mensagem\PYGZus{}venda” no console;
Como “mensagem\PYGZus{}venda” contém a string \PYGZdq{}O valor total da compra foi R\PYGZdl{} 30.\PYGZdq{}, essa é a saída.

Métodos integrados
As strings em Python vêm com uma variedade de métodos integrados que permitem realizar operações comuns em strings sem a necessidade de escrever funções adicionais. Esses métodos são essencialmente funções que estão \PYGZdq{}ligadas\PYGZdq{} a objetos de string e podem ser chamados diretamente em qualquer string. Abaixo estão algumas das operações comuns e seus métodos correspondentes:

Conversão de Caso:
upper(): Converte todos os caracteres da string para maiúsculas.
lower(): Converte todos os caracteres da string para minúsculas.
capitalize(): Converte o primeiro caractere da string para maiúscula.
title(): Converte o primeiro caractere de cada palavra para maiúscula.
   
Verificação:
startswith(substring): Retorna True se a string começar com a substring especificada.
endswith(substring): Retorna True se a string terminar com a substring especificada.
isalpha(): Retorna True se todos os caracteres da string forem letras.
isdigit(): Retorna True se todos os caracteres da string forem dígitos.

Manipulação:
replace(old, new): Substitui todas as ocorrências da substring old pela substring new.
strip(): Remove espaços em branco (ou outros caracteres especificados) do início e do final da string.
split(delimiter): Divide a string no delimiter especificado e retorna uma lista de substrings.

Busca:
find(substring): Retorna o índice da primeira ocorrência da substring. Se a substring não for encontrada, retorna “\PYGZhy{}1”.
count(substring): Retorna o número de ocorrências não sobrepostas da substring na string original.

e) Outros:
join(iterable): Une um iterável (como uma lista) em uma única string usando a string como delimitador.
len(string): Embora não seja exatamente um método de string, a função len() retorna o número de caracteres em uma string.

Exemplos:

```\PYGZob{}code\PYGZhy{}cell\PYGZcb{} python
texto = \PYGZsq{}Introdução a programação, para Geoprocessamento.\PYGZsq{}

print(texto.lower())  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{texto}\PYG{o}{.}\PYG{n}{upper}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{texto}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ã}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{texto}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
2.3 Estruturas de dados

\sphinxAtStartPar
As estruturas de dados são formas organizadas e eficientes de armazenar, acessar e manipular conjuntos de dados. Elas definem a relação entre os dados e as operações que podem ser realizadas sobre eles. A escolha da estrutura de dados adequada é crucial para a implementação eficiente de algoritmos e pode impactar significativamente o desempenho e a usabilidade de um programa. As estruturas de dados (figura 3) que serão contempladas em nosso estudo são as Listas, as Tuplas, os Dicionários e os Conjuntos.

\sphinxAtStartPar
Figura 3: Estruturas de dados em Python.

\sphinxAtStartPar
As razões pelas quais as estruturas de dados são tão importantes incluem:

\sphinxAtStartPar
Eficiência Computacional: Diferentes estruturas de dados têm diferentes custos em termos de tempo e espaço. Escolher a estrutura de dados certa pode permitir que os algoritmos operem mais rapidamente, economizando tempo de CPU e memória;
Organização de Dados: Estruturas de dados permitem que os dados sejam organizados de forma a serem facilmente acessíveis. Por exemplo, um dicionário em Python permite recuperar um valor em tempo constante, dada uma chave;
Facilita a Implementação de Algoritmos: Muitos algoritmos têm requisitos específicos quanto à forma como os dados devem ser armazenados para que funcionem corretamente e eficientemente. As estruturas de dados fornecem os meios para atender a esses requisitos;
Flexibilidade: Com a variedade de estruturas de dados disponíveis, os programadores podem escolher a estrutura que melhor se adapta à natureza dos dados e às operações que precisam ser realizadas sobre eles;
Redução de Complexidade: Usar a estrutura de dados apropriada pode reduzir a complexidade do código, tornando\sphinxhyphen{}o mais legível e fácil de manter;
Abstração: Estruturas de dados geralmente vêm com operações padrão que podem ser realizadas sobre elas (como inserir, excluir, pesquisar). Isso permite voltar a atenção para o problema que se está tentando resolver ao invés de se preocupar com os detalhes de como essas operações são implementadas;
Escalabilidade: À medida que os conjuntos de dados crescem, a importância de usar a estrutura de dados correta torna\sphinxhyphen{}se ainda mais crítica. Algumas estruturas que funcionam bem para pequenas quantidades de dados tornam\sphinxhyphen{}se impraticáveis em escala maior;
Aprimoramento da Tomada de Decisões: Em aplicações de negócios e análise de dados, as estruturas de dados adequadas podem facilitar a análise de grandes conjuntos de dados, levando a decisões mais informadas.

\sphinxAtStartPar
Listas

\sphinxAtStartPar
Listas são estruturas de dados fundamentais em programação que representam coleções ordenadas de itens. Em muitas linguagens, inclusive em Python, as listas são dinâmicas, o que significa que elas podem crescer ou diminuir em tamanho conforme necessário. Os itens em uma lista são organizados sequencialmente, permitindo que os usuários acessem cada elemento por meio de um índice, que é uma posição numérica na lista. Esta natureza ordenada torna as listas adequadas para tarefas que exigem a manutenção da ordem dos dados, como quando se precisa de uma sequência específica de elementos.
As listas podem conter elementos de qualquer tipo, seja números, strings, ou até mesmo outras listas e objetos complexos. A mutabilidade é outra característica crucial das listas em Python. Isso significa que, após a criação de uma lista, é possível modificar seu conteúdo, adicionar novos itens ou remover itens existentes.
No contexto do geoprocessamento, as listas desempenham papel essencial na manipulação e análise de dados geoespaciais. Por exemplo, uma lista pode ser usada para armazenar uma série de pontos que definem uma rota ou um caminho. Em análises de cobertura de terreno, listas podem conter amostras de elevações em pontos específicos para gerar perfis topográficos. Em sistemas de informações geográficas (SIG), ao trabalhar com múltiplas camadas de dados, como áreas urbanas, corpos d’água e vegetação, uma lista pode ser empregada para armazenar e iterar sobre essas camadas. Além disso, ao realizar análises de proximidade, as listas podem ser utilizadas para armazenar e comparar coordenadas de diferentes objetos, ajudando a determinar, por exemplo, todos os pontos de interesse dentro de uma determinada distância de uma estrada ou rio.

\sphinxAtStartPar
Criação de listas
Listas são criadas colocando uma sequência de valores separados por vírgulas entre colchetes. Exemplos:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Lista de números}
\PYG{n}{numeros} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Lista de strings:}
\PYG{n}{pais} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Brasil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Uruguai}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Argentina}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Lista mista (com diferentes tipos de dados):}
\PYG{n}{dados\PYGZus{}mistos} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{42}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Manaus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{3.14}\PYG{p}{,} \PYG{k+kc}{True}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Python}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Lista vazia:}
\PYG{n}{lista\PYGZus{}vazia} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Lista aninhada:}
\PYG{n}{lista\PYGZus{}aninhada} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Acessando os elementos da lista
Acesso pelo Índice:
As listas são indexadas por números inteiros, começando por 0 para o primeiro item.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Acessando o primeiro elemento da lista \PYGZsq{}país\PYGZsq{}:}
\PYG{n}{primeiro\PYGZus{}pais} \PYG{o}{=} \PYG{n}{pais}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{primeiro\PYGZus{}pais}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Acessando o terceiro elemento da lista numeros:}
\PYG{n}{terceiro\PYGZus{}numero} \PYG{o}{=} \PYG{n}{numeros}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{terceiro\PYGZus{}numero}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Atenção:
Ao tentar acessar um índice que não existe na lista (por exemplo, pais3 quando a lista tem apenas 3 elementos) resultará em um IndexError.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pais}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Acesso com Índices Negativos:
Os índices negativos permitem acessar a lista do final para o começo.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Acessando} \PYG{n}{o} \PYG{n}{último} \PYG{n}{item} \PYG{n}{da} \PYG{n}{lista} \PYG{n}{país}\PYG{p}{:}
\PYG{n}{pais} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Brasil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Uruguai}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Argentina}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{ultimo\PYGZus{}pais} \PYG{o}{=} \PYG{n}{pais}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{ultimo\PYGZus{}pais}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: Argentina}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{penultimo\PYGZus{}registro} \PYG{o}{=} \PYG{n}{numeros}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{penultimo\PYGZus{}registro}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: Uruguai}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Fatiamento:
O fatiamento é uma técnica em Python que permite acessar uma subseção (ou “fatia”) de uma lista. A sintaxe geral do fatiamento é lista{[}início:fim:passo{]}, onde “início” é o índice inicial da fatia, “fim” é o índice onde a fatia termina (exclusivo) e “passo” é o intervalo entre os itens da fatia. Vejamos alguns exemplos.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dados\PYGZus{}mistos} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{42}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Manaus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{3.14}\PYG{p}{,} \PYG{k+kc}{True}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Python}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Acessando os três primeiros itens:}
\PYG{n}{primeiros\PYGZus{}tres} \PYG{o}{=} \PYG{n}{dados\PYGZus{}mistos}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{primeiros\PYGZus{}tres}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: [42, \PYGZsq{}Manaus\PYGZsq{}, 3.14]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Acessando itens do terceiro ao quinto:}
\PYG{n}{meio} \PYG{o}{=} \PYG{n}{dados\PYGZus{}mistos}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{meio}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: [3.14, True, \PYGZsq{}Python\PYGZsq{}]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Acessando os últimos três itens:}
\PYG{n}{ultimos\PYGZus{}tres} \PYG{o}{=} \PYG{n}{dados\PYGZus{}mistos}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{ultimos\PYGZus{}tres}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: [True, \PYGZsq{}Python\PYGZsq{}, 7]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Acessando itens de dois em dois:}
\PYG{n}{passo\PYGZus{}dois} \PYG{o}{=} \PYG{n}{dados\PYGZus{}mistos}\PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{passo\PYGZus{}dois}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: [42, 3.14, \PYGZsq{}Python}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Acesso múltiplo (ou desempacotamento)
Permite atribuir vários elementos de uma lista (ou tupla) a variáveis diferentes em uma única linha. Suponha que temos uma lista representando dados sobre uma cidade: nome da cidade, latitude e longitude.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cidade\PYGZus{}info} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Brasília}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{15.7797}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{47.9297}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Agora, vamos usar o desempacotamento para acessar múltiplos elementos da lista. É importante garantir que o número de variáveis à esquerda da atribuição corresponda ao número de elementos que você está tentando desempacotar da lista. Se houver uma discrepância, o Python lançará um erro.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{nome}\PYG{p}{,} \PYG{n}{lat}\PYG{p}{,} \PYG{n}{lon} \PYG{o}{=} \PYG{n}{cidade\PYGZus{}info}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Neste exemplo, o valor “Brasília” da lista cidade\_info será atribuído à variável nome, o valor \sphinxhyphen{}17.7797 será atribuído à variável “lat”, e o valor \sphinxhyphen{}47.9297 será atribuído à variável “lon”.	Imprimindo os valores das variáveis:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{nome}\PYG{p}{,} \PYG{n}{lat}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{)} 
\PYG{c+c1}{\PYGZsh{} Saída: Brasília \PYGZhy{}15.7797 \PYGZhy{}47.9297}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Acesso por funções Built\sphinxhyphen{}in:
Podemos acessar os dados de uma lista utilizando funções do Python. Funções comumente utilizadas são len(), max() e min():

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{altitudes} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{320}\PYG{p}{,} \PYG{l+m+mi}{540}\PYG{p}{,} \PYG{l+m+mi}{890}\PYG{p}{,} \PYG{l+m+mi}{1200}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{650}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Usando len() para determinar o número de elementos na lista}
\PYG{n}{numero\PYGZus{}registros} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{altitudes}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{numero\PYGZus{}registros}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Saída: 6}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Usando max() para encontrar a maior altitude}
\PYG{n}{maior\PYGZus{}altitude} \PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{altitudes}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Saída: 1200}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Usando o min() para determinar a menor altitude}
\PYG{n}{menor\PYGZus{}altitude} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{altitudes}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{menor\PYGZus{}altitude}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Saída: 45}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Apresentamos nesta seção alguns conceitos básicos sobre a criação de listas e acesso aos seus elementos em Python. Mais adiante, veremos como acessar listar por iteração. Outro conceito importante que será estudado é o de “List comprehension”.

\sphinxAtStartPar
Modificação de listas: adição e remoção de elementos

\sphinxAtStartPar
As listas são mutáveis, o que significa que podemos alterar seus elementos após a criação. No contexto de modificar listas, há duas operações fundamentais: adicionar e remover elementos. Adicionar elementos pode envolver a inclusão de um único item, anexando\sphinxhyphen{}o ao final da lista, ou inserindo\sphinxhyphen{}o em uma posição específica. Também é possível juntar duas listas, expandindo uma com os elementos da outra. Por outro lado, a remoção de elementos pode se referir à exclusão de um item específico, independentemente de sua posição, ou à retirada de um item com base em sua posição. A capacidade de manipular listas dessa maneira oferece uma flexibilidade imensa, sendo um pilar central na manipulação de dados em Python.

\sphinxAtStartPar
Adicionando elementos a uma lista:
Método append(): Adiciona um item ao final da lista.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pontos\PYGZus{}referencia} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Montanha}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Rio}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Floresta}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{pontos\PYGZus{}referencia}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Lago}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{pontos\PYGZus{}referencia}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: [\PYGZsq{}Montanha\PYGZsq{}, \PYGZsq{}Rio\PYGZsq{}, \PYGZsq{}Floresta\PYGZsq{}, \PYGZsq{}Lago\PYGZsq{}]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Método insert(): Insere um item em uma posição específica.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pontos\PYGZus{}referencia}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Vale}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{pontos\PYGZus{}referencia}\PYG{p}{)}  
\PYG{c+c1}{\PYGZsh{} Saída: [\PYGZsq{}Vale\PYGZsq{}, \PYGZsq{}Montanha\PYGZsq{}, \PYGZsq{}Rio\PYGZsq{}, \PYGZsq{}Floresta\PYGZsq{}, \PYGZsq{}Lago\PYGZsq{}]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Método extend() ou “+=”: Adiciona múltiplos elementos à lista.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{coordenadas} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mf}{12.34}\PYG{p}{,} \PYG{l+m+mf}{56.78}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{23.45}\PYG{p}{,} \PYG{l+m+mf}{67.89}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{novas\PYGZus{}coordenadas} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mf}{34.56}\PYG{p}{,} \PYG{l+m+mf}{78.90}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{45.67}\PYG{p}{,} \PYG{l+m+mf}{89.01}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{coordenadas}\PYG{o}{.}\PYG{n}{extend}\PYG{p}{(}\PYG{n}{novas\PYGZus{}coordenadas}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{coordenadas}\PYG{p}{)}  
\PYG{c+c1}{\PYGZsh{} Saída: [(12.34, 56.78), (23.45, 67.89), (34.56, 78.90), (45.67, 89.01)]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Usando +=}
\PYG{n}{coordenadas2} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mf}{12.34}\PYG{p}{,} \PYG{l+m+mf}{56.78}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{23.45}\PYG{p}{,} \PYG{l+m+mf}{67.89}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{coordenadas2} \PYG{o}{+}\PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mf}{34.56}\PYG{p}{,} \PYG{l+m+mf}{78.90}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{45.67}\PYG{p}{,} \PYG{l+m+mf}{89.01}\PYG{p}{)}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{coordenadas2}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Saída: [(12.34, 56.78), (23.45, 67.89), (34.56, 78.90), (45.67, 89.01)]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Removendo elementos de uma lista:

\sphinxAtStartPar
Método remove(): Remove a primeira ocorrência do valor especificado.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rios} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Amazonas}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{São Francisco}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tietê}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{rios}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tietê}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{rios}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: [\PYGZsq{}Amazonas\PYGZsq{}, \PYGZsq{}São Francisco\PYGZsq{}]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Método pop(): Remove e retorna o item na posição especificada (ou o último item se a posição não for especificada).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{montanhas} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Andes}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Himalaia}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Alpes}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{montanha\PYGZus{}removida} \PYG{o}{=} \PYG{n}{montanhas}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{montanha\PYGZus{}removida}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: \PYGZsq{}Himalaia\PYGZsq{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{montanhas}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: [\PYGZsq{}Andes\PYGZsq{}, \PYGZsq{}Al}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Instrução del: Remove o item na posição especificada ou uma fatia de itens.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{regioes} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Norte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sul}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sudeste}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Nordeste}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Centro\PYGZhy{}Oeste}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{del} \PYG{n}{regioes}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} Remove as regiões \PYGZsq{}Sudeste\PYGZsq{} e \PYGZsq{}Nordeste\PYGZsq{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{regioes}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: [\PYGZsq{}Norte\PYGZsq{}, \PYGZsq{}Sul\PYGZsq{}, \PYGZsq{}Centro\PYGZhy{}Oeste\PYGZsq{}]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Operações comuns: ordenamento, fatiamento, concatenação, repetição, membership.

\sphinxAtStartPar
No geoprocessamento, frequentemente trabalhamos com conjuntos de dados que precisam ser manipulados, analisados e transformados. As listas em Python oferecem várias operações comuns que são extremamente úteis neste contexto. Vamos explorar algumas delas com exemplos.

\sphinxAtStartPar
Ordenamento: Listas podem ser ordenadas para obter uma sequência crescente ou decrescente. Exemplo: Suponha que temos uma lista de altitudes de diferentes locais e queremos ordená\sphinxhyphen{}las.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{altitudes} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{312}\PYG{p}{,} \PYG{l+m+mi}{980}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{1235}\PYG{p}{,} \PYG{l+m+mi}{910}\PYG{p}{]}
\PYG{n}{altitudes}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{altitudes}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: [45, 312, 910, 980, 123}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Para ordenar a lista em ordem decrescente (ordenamento inverso), você pode usar o argumento reverse=True com o método sort().

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{altitudes}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{n}{reverse}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{altitudes}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: [1235, 980, 910, 312, 45]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Fatiamento (Slicing): O fatiamento permite obter subconjuntos de uma lista. Exemplo: Se tivermos uma lista de coordenadas e quisermos obter apenas as três primeiras:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{coordenadas} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mf}{12.34}\PYG{p}{,} \PYG{l+m+mf}{56.78}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{23.45}\PYG{p}{,} \PYG{l+m+mf}{67.89}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{34.56}\PYG{p}{,} \PYG{l+m+mf}{78.90}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{45.67}\PYG{p}{,} \PYG{l+m+mf}{89.01}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{primeiras\PYGZus{}tres} \PYG{o}{=} \PYG{n}{coordenadas}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{primeiras\PYGZus{}tres}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: [(12.34, 56.78), (23.45, 67.89), (34.56, 78.90)]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Concatenação: Podemos combinar listas para criar uma nova. Exemplo: Se tivermos duas listas de cidades e quisermos juntá\sphinxhyphen{}las:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cidades\PYGZus{}A} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Manaus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fortaleza}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{cidades\PYGZus{}B} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Goiânia}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Florianópolis}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{todas\PYGZus{}cidades} \PYG{o}{=} \PYG{n}{cidades\PYGZus{}A} \PYG{o}{+} \PYG{n}{cidades\PYGZus{}B}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{todas\PYGZus{}cidades}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: [\PYGZsq{}Manaus\PYGZsq{}, \PYGZsq{}Fortaleza\PYGZsq{}, \PYGZsq{}Goiânia\PYGZsq{}, \PYGZsq{}Florianópolis\PYGZsq{}]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Repetição: Listas podem ser repetidas usando o operador “*”. Exemplo: Criar uma lista de valores padrão para a qualidade do solo em diversas regiões:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qualidade\PYGZus{}padrao} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fértil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{*} \PYG{l+m+mi}{4}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{qualidade\PYGZus{}padrao}\PYG{p}{)}  
\PYG{c+c1}{\PYGZsh{} Saída: [\PYGZsq{}fértil\PYGZsq{}, \PYGZsq{}fértil\PYGZsq{}, \PYGZsq{}fértil\PYGZsq{}, \PYGZsq{}fértil\PYGZsq{}]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Membership: Podemos verificar se um elemento pertence a uma lista usando a palavra\sphinxhyphen{}chave “in”. Exemplo: Verificar se uma determinada cidade está em nossa lista de cidades monitoradas:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{resultado} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Rio de Janeiro}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{cidades\PYGZus{}A}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{resultado}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: False}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
2.3.2 Tuplas

\sphinxAtStartPar
As tuplas são uma das estruturas de dados em Python que permitem armazenar uma coleção ordenada de itens. Assim como as listas, as tuplas podem conter elementos de tipos diferentes. No entanto, há algumas diferenças importantes entre listas e tuplas:

\sphinxAtStartPar
Imutabilidade: Uma vez que uma tupla é criada, você não pode modificar seus elementos. Isso significa que você não pode adicionar, remover ou alterar elementos após a tupla ser definida. Essa imutabilidade faz das tuplas uma escolha segura para representar coleções de dados que não devem ser alteradas durante a execução de um programa;
Sintaxe: Tuplas são geralmente definidas colocando os elementos entre parênteses (), enquanto listas usam colchetes {[}{]}.
Uso: Devido à sua natureza imutável, as tuplas são frequentemente usadas em situações em que é necessário garantir que os dados não sejam modificados. Alguns exemplos incluem:
Chaves em dicionários: Em Python, as chaves de um dicionário devem ser imutáveis, tornando as tuplas uma opção adequada para chaves compostas.
Retorno de múltiplos valores de funções: É comum usar tuplas para retornar múltiplos valores de uma função.
Armazenar dados que não devem ser alterados: Se você tem uma coleção de valores que nunca devem ser alterados durante a vida útil do programa (por exemplo, constantes), as tuplas são uma opção natural.

\sphinxAtStartPar
No contexto do geoprocessamento, as tuplas desempenham vários papéis importantes, aproveitando sua natureza imutável e ordenada. Aqui estão algumas maneiras de como as tuplas podem ser aplicadas:

\sphinxAtStartPar
Coordenadas Geográficas: As tuplas são uma escolha natural para representar pontos no espaço, como coordenadas (latitude, longitude). Sua natureza imutável garante que as coordenadas de um ponto específico não sejam modificadas acidentalmente.
Dados matriciais: Em análises de dados matriciais, cada pixel pode ser representado por uma tupla que denota seu valor em várias bandas (por exemplo, bandas de imagem de satélite).
Atributos Compostos: Em muitos Sistemas de Informações Geográficas (SIG), os atributos associados a um objeto podem ser armazenados como tuplas. Por exemplo, um objeto representando um edifício pode ter um atributo que é uma tupla contendo (número de andares, área, ano de construção).
Chaves Únicas: No geoprocessamento, frequentemente, trabalhamos com bancos de dados espaciais. Quando se deseja criar chaves compostas para tabelas, as tuplas podem ser usadas para representar combinações únicas de diferentes colunas.
Retorno de Funções: Muitas funções em bibliotecas de geoprocessamento podem retornar múltiplos valores. Por exemplo, uma função que calcula a distância e o ângulo entre dois pontos retornaria ambos os valores como uma tupla.
Definição de Extensões Espaciais: Em algumas operações, como cortar ou recortar um dataset, é necessário definir a extensão espacial (bounding box). Isso pode ser representado por uma tupla de valores mínimos e máximos (xmin, ymin, xmax, ymax).
Especificação de Parâmetros: Muitas operações geoespaciais exigem um conjunto de parâmetros que não mudam durante a operação. Uma tupla pode armazenar esses valores de maneira confiável.

\sphinxAtStartPar
Criação de tuplas
A criação de tuplas pode ser realizada de acordo com os exemplos a seguir:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Tupla vazia}
\PYG{n}{nome} \PYG{o}{=} \PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Criação de tupla com coordenadas geográficas}
\PYG{n}{coordenada} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{45.4215}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{75.6972}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}As tuplas podem ser criadas com ou sem a inserção de parênteses.}
\PYG{n}{coordenada} \PYG{o}{=} \PYG{l+m+mf}{45.4215}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{75.6972} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Tupla mista, com dados do tipo string e do tipo inteiro.}
\PYG{n}{rio\PYGZus{}info} \PYG{o}{=} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Rio Amazonas}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{6575}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{América do Sul}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Tupla aninhada (contendo tuplas e listas)}
\PYG{n}{tupla\PYGZus{}aninhada} \PYG{o}{=} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Acessando os elementos de uma tupla
O acesso aos elementos de uma tupla em Python é feito de maneira análoga às listas. Seja por índice, acesso negativo, fatiamento, desempacotamento, uso de funções built\sphinxhyphen{}in ou loops, as técnicas usadas para acessar os elementos são as mesmas para ambas as estruturas de dados. A seguir temos um exemplo de acessos aos elementos da tupla “temperaturas”.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Criação de tupla com elementos representando a altitude}
\PYG{n}{temperaturas} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{20.5}\PYG{p}{,} \PYG{l+m+mf}{23.2}\PYG{p}{,} \PYG{l+m+mf}{18.7}\PYG{p}{,} \PYG{l+m+mf}{21.9}\PYG{p}{,} \PYG{l+m+mf}{19.4}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{primeira\PYGZus{}temp} \PYG{o}{=} \PYG{n}{temperaturas}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{primeira\PYGZus{}temp}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: 20.5}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ultima\PYGZus{}temp} \PYG{o}{=} \PYG{n}{temperaturas}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{ultima\PYGZus{}temp}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: 19.4}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sub\PYGZus{}tupla} \PYG{o}{=} \PYG{n}{temperaturas}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{sub\PYGZus{}tupla}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: (23.2, 18.7, 21.9)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{t1}\PYG{p}{,} \PYG{n}{t2}\PYG{p}{,} \PYG{n}{t3}\PYG{p}{,} \PYG{n}{t4}\PYG{p}{,} \PYG{n}{t5} \PYG{o}{=} \PYG{n}{temperaturas}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{t1}\PYG{p}{,} \PYG{n}{t2}\PYG{p}{,} \PYG{n}{t3}\PYG{p}{,} \PYG{n}{t4}\PYG{p}{,} \PYG{n}{t5}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: 20.5 23.2 18.7 21.9 19.4}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tamanho} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{temperaturas}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{tamanho}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: 5}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{temp\PYGZus{}max} \PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{temperaturas}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{temp\PYGZus{}max}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: 23.2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{temp\PYGZus{}min} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{temperaturas}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{temp\PYGZus{}min}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Saída: 18.7}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Conversão entre listas e tuplas
A conversão entre listas e tuplas é uma tarefa comum e fácil de realizar em Python. Tanto é possível converter uma lista em uma tupla quanto converter uma tupla em uma lista, conforme exemplos a seguir:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Convertendo uma lista em uma tupla}
\PYG{n}{lista} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}
\PYG{n}{tupla} \PYG{o}{=} \PYG{n+nb}{tuple}\PYG{p}{(}\PYG{n}{lista}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Verificando o tipo de dado}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tipo de dado após a conversão:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{tupla}\PYG{p}{)}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Saída: Tipo de dado após a conversão: \PYGZlt{}class \PYGZsq{}tuple\PYGZsq{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Convertendo uma tupla em uma lista}
\PYG{n}{tupla} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{lista} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{tupla}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Verificando o tipo de dado}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tipo de dado após a conversão:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{lista}\PYG{p}{)}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Saída: Tipo de dado após a conversão: \PYGZlt{}class \PYGZsq{}list\PYGZsq{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Essas conversões são úteis quando você tem uma tupla, mas precisa modificar alguns de seus elementos (o que não pode ser feito diretamente, pois as tuplas são imutáveis) ou quando você tem uma lista e quer garantir que seus elementos não sejam alterados acidentalmente em outra parte do código.  No entanto, é importante observar que essas operações criam novas instâncias de objetos e não alteram as originais. Então, se você modificar a nova lista criada a partir de uma tupla, a tupla original permanecerá inalterada e vice\sphinxhyphen{}versa.

\sphinxAtStartPar
Como escolher entre a utilização de tuplas ou de listas?
Escolher entre tuplas e listas em Python geralmente depende do contexto e da intenção do uso. Aqui estão algumas diretrizes para ajudá\sphinxhyphen{}lo a decidir:

\sphinxAtStartPar
a) Imutabilidade:
Tuplas: São imutáveis. Uma vez que você cria uma tupla, não pode alterar seus elementos ou seu tamanho. Isso é útil quando você quer garantir que os dados permaneçam constantes e não sejam alterados acidentalmente em qualquer parte do programa.
Listas: São mutáveis. Você pode modificar, adicionar ou remover elementos de uma lista após sua criação.

\sphinxAtStartPar
b) Semântica:
Tuplas: Em muitos contextos, tuplas são usadas para representar coleções de itens heterogêneos (por exemplo, coordenadas (x, y), dados de um banco (nome, idade, endereço)). Elas geralmente têm um número fixo de elementos, cada um com um significado específico.
Listas: São geralmente usadas para coleções homogêneas de itens, onde cada item tem o mesmo tipo e significado (por exemplo, uma lista de números, uma lista de nomes).

\sphinxAtStartPar
c) Desempenho:
Tuplas: Como são imutáveis, tuplas podem ser ligeiramente mais rápidas do que listas em certas operações, como iteração.
Listas: Devido à sua natureza mutável, operações que alteram a lista (como adicionar ou remover elementos) podem ter um custo de desempenho.

\sphinxAtStartPar
d) Uso em dicionários:
Tuplas: Podem ser usadas como chaves em dicionários, devido à sua imutabilidade.
Listas: Não podem ser usadas como chaves em dicionários, porque são mutáveis.

\sphinxAtStartPar
e) Intenção:
Tuplas: Transmitir ao leitor do código que a coleção não deve ser modificada.
Listas: Indicar que a coleção pode ser modificada, e que funções ou métodos que alteram listas podem ser aplicados.

\sphinxAtStartPar
f) Espaço em memória:
Tuplas: Podem ser mais eficientes em termos de espaço em relação às listas, porque não têm o overhead adicional associado à mutabilidade das listas.

\sphinxAtStartPar
Na prática, use tuplas para:
Representar coleções imutáveis de itens;
Atuar como chaves em dicionários;
Garantir que os dados não sejam modificados acidentalmente;
Retornar múltiplos valores de funções.

\sphinxAtStartPar
Use listas para:
Representar coleções que podem requerer alterações;
Realizar diversas operações como inserção, remoção, etc.;
Armazenar coleções de dados que são dinâmicos por natureza.

\begin{sphinxthebibliography}{HdHPK14}
\bibitem[HdHPK14]{markdown:id3}
\sphinxAtStartPar
Christopher Ramsay Holdgraf, Wendy de Heer, Brian N. Pasley, and Robert T. Knight. Evidence for Predictive Coding in Human Auditory Cortex. In \sphinxstyleemphasis{International Conference on Cognitive Neuroscience}. Brisbane, Australia, Australia, 2014. Frontiers in Neuroscience.
\end{sphinxthebibliography}







\renewcommand{\indexname}{Index}
\printindex
\end{document}