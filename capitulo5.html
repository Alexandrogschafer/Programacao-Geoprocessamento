

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>5 A BIBLIOTECA GEOPANDAS &#8212; Programação para Geoprocessamento</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=365ca57ee442770a23c6" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=365ca57ee442770a23c6" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=365ca57ee442770a23c6" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=365ca57ee442770a23c6" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=365ca57ee442770a23c6" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=365ca57ee442770a23c6" />
  <script src="_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=365ca57ee442770a23c6"></script>

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'capitulo5';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="6. VISUALIZAÇÃO DE DADOS GEOESPACIAIS NO PYTHON" href="capitulo6.html" />
    <link rel="prev" title="4. GEOPROCESSAMENTO BÁSICO COM SHAPELY E FIONA" href="capitulo4.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/pythongeo.png" class="logo__image only-light" alt="Programação para Geoprocessamento - Home"/>
    <script>document.write(`<img src="_static/pythongeo.png" class="logo__image only-dark" alt="Programação para Geoprocessamento - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    Meu Jupyter Book
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="capitulo1.html">1. INTRODUÇÃO</a></li>
<li class="toctree-l1"><a class="reference internal" href="capitulo2.html">2. FUNDAMENTOS DA LINGUAGEM PYTHON</a></li>
<li class="toctree-l1"><a class="reference internal" href="capitulo3.html">3. A BIBLIOTECA PANDAS</a></li>
<li class="toctree-l1"><a class="reference internal" href="capitulo4.html">4. GEOPROCESSAMENTO BÁSICO COM SHAPELY E FIONA</a></li>

<li class="toctree-l1 current active"><a class="current reference internal" href="#">5 A BIBLIOTECA GEOPANDAS</a></li>
<li class="toctree-l1"><a class="reference internal" href="capitulo6.html">6. VISUALIZAÇÃO DE DADOS GEOESPACIAIS NO PYTHON</a></li>




<li class="toctree-l1"><a class="reference internal" href="referencias.html">REFERÊNCIAS BIBLIOGRÁFICAS:</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/alexandrogschafer/Programacao-Geoprocessamento" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/alexandrogschafer/Programacao-Geoprocessamento/issues/new?title=Issue%20on%20page%20%2Fcapitulo5.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/capitulo5.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>5 A BIBLIOTECA GEOPANDAS</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#funcoes-apply-map-e-replace-no-contexto-do-geopandas">5.3 Funções apply, map e replace no contexto do Geopandas</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#a-funcao-apply-no-geopandas">5.3.1 A função apply no Geopandas</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#as-funcoes-map-e-replace-no-geopandas">5.3.2 As funções map e replace no Geopandas</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#anexacao-metodo-concat">5.4.1 Anexação: Método concat</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#juncoes-de-atributos-attribute-joins">5.4.2 Junções de Atributos (Attribute Joins)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#selecao-e-filtragem-de-dados">5.5 Seleção e filtragem de dados</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#selecao-com-base-em-atributos">5.5.1 Seleção com base em atributos</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#selecao-com-base-em-condicoes">5.5.1.1 Seleção com base em Condições</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#o-metodo-query">5.5.1.2 O Método query</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#selecao-de-subconjuntos-via-coordenadas-bounding-box-com-notacao-slice">5.5.2 Seleção de subconjuntos via coordenadas: bounding box com notação slice.</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#operacoes-espaciais-no-geopandas">5.6 Operações espaciais no Geopandas</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operacoes-metricas">5.6.1 Operações métricas</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operacoes-de-transformacao">5.6.2 Operações de transformação</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operacoes-de-generalizacao">5.6.3 Operações de generalização</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operacoes-de-decomposicao">5.6.4 Operações de decomposição</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operacoes-entre-multiplos-geodataframes">5.6.5 Operações entre multiplos geodataframes</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#cortando-geometrias-com-a-ferramenta-clip">5.6.5.1 Cortando Geometrias com a ferramenta Clip</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#predicados-espaciais-uma-introducao">5.6.5.2 Predicados Espaciais: Uma Introdução</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#diferentes-maneiras-de-utilizar-operacoes-e-predicados-espaciais-com-dois-ou-mais-geodataframes-no-contexto-do-geopandas">5.6.5.3 Diferentes maneiras de utilizar operações e predicados espaciais com dois ou mais GeoDataFrames no contexto do Geopandas</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#juncoes-espaciais-spatial-joins">5.6.5.4 Junções Espaciais (Spatial Joins)</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#operacoes-de-conjunto-com-sobreposicao-overlay">5.6.5.5 Operações de conjunto com sobreposição (overlay)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="a-biblioteca-geopandas">
<h1>5 A BIBLIOTECA GEOPANDAS<a class="headerlink" href="#a-biblioteca-geopandas" title="Permalink to this heading">#</a></h1>
<p>Em um mundo cada vez mais orientado por dados, a capacidade de trabalhar com informações geoespaciais tornou-se fundamental em diversas áreas, desde o planejamento urbano até a ecologia e ciências ambientais. Neste contexto, o Geopandas emerge como uma importante ferramenta para a análise geoespacial em Python.</p>
<p>Geopandas é uma extensão do Pandas que introduz estruturas de dados espaciais. Ele apresenta duas estruturas de dados principais (figura 27): GeoSeries e GeoDataFrame. Uma GeoSeries é uma série em que cada entrada representa um conjunto geométrico. Por sua vez, um GeoDataFrame assemelha-se a um DataFrame padrão do Pandas, porém, inclui uma coluna especial denominada “geometry”, responsável por armazenar informações geoespaciais.</p>
<p>Figura 27: estruturas de dados do Geopandas.</p>
<p>O Geopandas é capaz de lidar com uma variedade de tipos geométricos, abrangendo pontos, linhas, polígonos e combinações destes. Esta capacidade é complementada por uma série de operações espaciais, possíveis graças à integração com bibliotecas como Shapely e Fiona. Estas operações incluem, mas não se limitam a, interseção, união, diferença e buffer. Além disso, a biblioteca oferece ferramentas robustas para análise espacial, permitindo o cálculo de áreas, distâncias e outras métricas geométricas essenciais.</p>
<p>A flexibilidade do Geopandas não se restringe apenas às operações mencionadas. Ele pode ler e escrever em diversos formatos de dados espaciais, incluindo shapefile e GeoJSON. Além disso, suporta operações de projeção e transformações entre sistemas de coordenadas. Para os profissionais que trabalham com bancos de dados espaciais, o Geopandas também pode ser integrado ao PostGIS, facilitando operações avançadas e consultas SQL. Quando se trata de visualização, a biblioteca se integra perfeitamente a outras soluções Python, como Matplotlib, Plotly e Folium, oferecendo um vasto leque de opções para representação gráfica de dados geoespaciais.</p>
<p>Leitura de arquivos</p>
<p>O Geopandas tem a capacidade de simplificar a leitura de arquivos geoespaciais em Python, suportando uma variedade de formatos comuns na área de Geoprocessamento.</p>
<p>O método gpd.read_file é uma função da biblioteca Geopandas que permite ler diferentes formatos de arquivos de dados geoespaciais e convertê-los em um GeoDataFrame. Quando você utiliza o gpd.read_file, o Geopandas faz uso da biblioteca Fiona internamente para ler o arquivo. Isso significa que ele pode lidar com uma variedade de formatos de arquivo, incluindo Shapefiles (.shp), GeoJSON, GPKG, entre outros.</p>
<p>Lendo Shapefiles com Geopandas</p>
<p>Você pode ler um arquivo Shapefile da seguinte maneira:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
</pre></div>
</div>
</div>
</div>
<p>Carregar o Shapefile em um GeoDataFrame</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/4_br_uf/BR_UF.shp&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Mostrar as primeiras linhas do GeoDataFrame</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>CD_UF</th>
      <th>NM_UF</th>
      <th>SIGLA_UF</th>
      <th>NM_REGIAO</th>
      <th>AREA_KM2</th>
      <th>geometry</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>12</td>
      <td>Acre</td>
      <td>AC</td>
      <td>Norte</td>
      <td>164173.429</td>
      <td>POLYGON ((-68.79282 -10.99957, -68.79367 -10.9...</td>
    </tr>
    <tr>
      <th>1</th>
      <td>13</td>
      <td>Amazonas</td>
      <td>AM</td>
      <td>Norte</td>
      <td>1559255.881</td>
      <td>POLYGON ((-56.76292 -3.23221, -56.76789 -3.242...</td>
    </tr>
    <tr>
      <th>2</th>
      <td>15</td>
      <td>Pará</td>
      <td>PA</td>
      <td>Norte</td>
      <td>1245870.704</td>
      <td>MULTIPOLYGON (((-48.97548 -0.19834, -48.97487 ...</td>
    </tr>
    <tr>
      <th>3</th>
      <td>16</td>
      <td>Amapá</td>
      <td>AP</td>
      <td>Norte</td>
      <td>142470.762</td>
      <td>MULTIPOLYGON (((-51.04561 -0.05088, -51.05422 ...</td>
    </tr>
    <tr>
      <th>4</th>
      <td>17</td>
      <td>Tocantins</td>
      <td>TO</td>
      <td>Norte</td>
      <td>277423.627</td>
      <td>POLYGON ((-48.24830 -13.19239, -48.24844 -13.1...</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Após ler o arquivo, ele é armazenado no GeoDataFrame gdf; gdf.head() imprime as primeiras cinco linhas do GeoDataFrame gdf usando o método head(), o que é útil para se ter uma visão rápida dos dados e verificar se tudo foi carregado e convertido corretamente.</p>
<p>Observações:</p>
<p>Dependências: O Geopandas depende de várias outras bibliotecas, como Fiona (para leitura/escrita de arquivos) e Shapely (para operações geométricas). Ao instalar o Geopandas via pip, estas dependências também serão instaladas.</p>
<p>Projeção: Muitas vezes, é uma boa prática verificar a projeção do Shapefile depois de carregá-lo, especialmente se você planeja combinar dados de várias fontes. Você pode fazer isso usando gdf.crs.</p>
<p>Consultar o sistema de projeção</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>epsg:4674
</pre></div>
</div>
</div>
</div>
<p>Plotando GeoDataFrames com Geopandas</p>
<p>O Geopandas permite a visualização de GeoDataFrames, facilitando a visualização das geometrias no espaço geográfico. Para exibir a geometria ativa, utilize o método GeoDataFrame.plot().</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;AxesSubplot:&gt;
</pre></div>
</div>
<img alt="_images/0a119fdbb8c58287520520ded2d3c479c4c7de159f3b19e09a2eff3ddd63492a.png" src="_images/0a119fdbb8c58287520520ded2d3c479c4c7de159f3b19e09a2eff3ddd63492a.png" />
</div>
</div>
<p>No exemplo a seguir, exibimos a coluna de geometria ativa e usamos a coluna “NM_REGIAO” para determinar as cores por regiões do Brasil. Além disso, optamos por exibir uma legenda usando legend=True.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="s1">&#39;NM_REGIAO&#39;</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;AxesSubplot:&gt;
</pre></div>
</div>
<img alt="_images/d012a73ac981df68da21ac308fa557ad41f70b137bf1acf90c0eab068f2e574d.png" src="_images/d012a73ac981df68da21ac308fa557ad41f70b137bf1acf90c0eab068f2e574d.png" />
</div>
</div>
<p>Esta é uma breve apresentação do método GeoDataFrame.plot() para possibilitar a visualização dos GeoDataFrames ao longo do estudo do Geopandas. Após estudar o Geopandas, teremos uma seção sobre visualização de dados geoespaciais.</p>
<p>Lendo dados com Geopandas – outros arquivos</p>
<p>GeoJSON</p>
<p>Como vimos anteriormente, o GeoJSON é um formato baseado em JSON para codificar estruturas geográficas. Para ler um arquivo GeoJSON:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_cap</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/5_capitais_br_geojson/capitais_br.geojson&#39;</span><span class="p">)</span>
<span class="n">gdf_cap</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>capital</th>
      <th>estado</th>
      <th>codigo</th>
      <th>geometry</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Brasília</td>
      <td>Distrito Federal</td>
      <td>5300108</td>
      <td>POINT (-47.88250 -15.79340)</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Rio Branco</td>
      <td>Acre</td>
      <td>1200401</td>
      <td>POINT (-67.82700 -9.97499)</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Maceió</td>
      <td>Alagoas</td>
      <td>2704302</td>
      <td>POINT (-35.73530 -9.66599)</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Manaus</td>
      <td>Amazonas</td>
      <td>1302603</td>
      <td>POINT (-60.02530 -3.11333)</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Macapá</td>
      <td>Amapá</td>
      <td>1600303</td>
      <td>POINT (-51.07050 0.03945)</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_cap</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;AxesSubplot:&gt;
</pre></div>
</div>
<img alt="_images/a15771329ae32b9ce4a2a741de04857f2b1d024b1335c122510c1f940cdfd328.png" src="_images/a15771329ae32b9ce4a2a741de04857f2b1d024b1335c122510c1f940cdfd328.png" />
</div>
</div>
<p>É possível visualizar geometricamente os dados de dois GeoDataFrame do Geopandas em um único gráfico. Por enquanto, vamos apenas aplicar o script para gerar a visualização. Estudaremos o método plot() mais adiante.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ax</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="n">gdf_cap</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;AxesSubplot:&gt;
</pre></div>
</div>
<img alt="_images/6f4e98d68184c03687389de8d9e05b459ac42c405fa92adeb08e144d71c8bace.png" src="_images/6f4e98d68184c03687389de8d9e05b459ac42c405fa92adeb08e144d71c8bace.png" />
</div>
</div>
<p>GPKG (GeoPackage)</p>
<p>GeoPackage é um formato de banco de dados aberto e padrão que pode conter múltiplas camadas. Você pode listar e selecionar camadas específicas:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_rod</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/6_geopackage/malha_transporte.gpkg&#39;</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="s1">&#39;trecho_rodoviario&#39;</span><span class="p">)</span>
<span class="n">gdf_fer</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/6_geopackage/malha_transporte.gpkg&#39;</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="s1">&#39;trecho_ferroviario&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>No código acima, em layer=’trecho_rodoviario’, o argumento layer especifica a camada ou tabela dentro do Geopackage que desejamos ler. Em um Geopackage, você pode ter várias camadas (ou tabelas) diferentes, e essa especificação permite que você selecione qual delas deseja carregar. Neste caso, estamos escolhendo a camada chamada trecho_rodoviario.</p>
<p>No código seguinte, especificamos o layer ‘trecho_ferroviario’. Vamos visualizar os GeoDataFrames criados:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_rod</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">gdf_fer</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;AxesSubplot:&gt;
</pre></div>
</div>
<img alt="_images/abefce82675319a30759465ff333f1525848069528d027157cf2d7fd5f4cc5a9.png" src="_images/abefce82675319a30759465ff333f1525848069528d027157cf2d7fd5f4cc5a9.png" />
<img alt="_images/0e9b7d0ed4b784f96b5fa4817edd4270a524c1331089c101c6f2871ebaa27b29.png" src="_images/0e9b7d0ed4b784f96b5fa4817edd4270a524c1331089c101c6f2871ebaa27b29.png" />
</div>
</div>
<p>CSV com Coordenadas: Convertendo dados tabulares em dados geoespaciais</p>
<p>Caso tenhamos um arquivo CSV com colunas de latitude e longitude, primeiro podemos ler o arquivo com o Pandas e depois converter o DataFrame para um GeoDataFrame.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Point</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/7_capitais_CSV/capitais_brasil.csv&#39;</span><span class="p">)</span>
<span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span>
    <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">latitude</span><span class="p">))</span>
<span class="n">gdf</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>capital</th>
      <th>longitude</th>
      <th>latitude</th>
      <th>geometry</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Brasília</td>
      <td>-47.8825</td>
      <td>-15.793400</td>
      <td>POINT (-47.88250 -15.79340)</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Rio Branco</td>
      <td>-67.8270</td>
      <td>-9.974990</td>
      <td>POINT (-67.82700 -9.97499)</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Maceió</td>
      <td>-35.7353</td>
      <td>-9.665990</td>
      <td>POINT (-35.73530 -9.66599)</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Manaus</td>
      <td>-60.0253</td>
      <td>-3.113330</td>
      <td>POINT (-60.02530 -3.11333)</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Macapá</td>
      <td>-51.0705</td>
      <td>0.039452</td>
      <td>POINT (-51.07050 0.03945)</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Em resumo, o código lê um arquivo CSV contendo informações sobre as capitais brasileiras (incluindo suas coordenadas de longitude e latitude), converte essas coordenadas em pontos geoespaciais e armazena tudo em um GeoDataFrame. O parâmetro geometry é usado para definir a coluna de geometria do GeoDataFrame. A função gpd.points_from_xy(df.longitude, df.latitude) é usada para criar pontos a partir das colunas longitude e latitude do DataFrame df. Por fim, as primeiras cinco linhas desse GeoDataFrame são impressas para visualização.</p>
<p>Leitura Seletiva de Dados</p>
<p>Se um arquivo geoespacial contiver um grande volume de dados, pode ser útil ler apenas uma subseção ou uma amostra dos dados. Você pode fazer isso usando os argumentos rows ou bbox no método read_file.</p>
<p>a) Argumento rows</p>
<p>Ler apenas as primeiras 10 linhas</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/4_br_uf/BR_UF.shp&#39;</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>No código acima, serão lidas apenas as primeiras dez linhas do arquivo shapefile.</p>
<p>b) Argumento bbox (bounding box)</p>
<p>Uma bounding box (ou retângulo envolvente) refere-se ao retângulo de dimensões mínimas que envolve um conjunto geométrico, definido pelos cantos inferior esquerdo e superior direito. Cada ponto é definido por uma coordenada de longitude e latitude. Esse retângulo frequentemente é usado para operações rápidas de verificação espacial, pois trabalhar com um retângulo é computacionalmente mais simples do que com formas geométricas mais complexas.</p>
<p>Exemplo: Vamos ler o arquivo shapefile BR_UF novamente, mas agora especificando uma bounding box.</p>
<p>Ler dados dentro de uma bounding box específica (minx, miny, maxx, maxy)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">bbox</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">53.8</span><span class="p">,</span> <span class="o">-</span><span class="mf">29.4</span><span class="p">,</span> <span class="o">-</span><span class="mf">48.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">25.8</span><span class="p">]</span>
<span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/4_br_uf/BR_UF.shp&#39;</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">bbox</span><span class="p">)</span>
<span class="n">gdf</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;AxesSubplot:&gt;
</pre></div>
</div>
<img alt="_images/cd37b1e90b79db2c8e83204a29201d8dd722b01da2f5fa46bf11ffcd1dbb402e.png" src="_images/cd37b1e90b79db2c8e83204a29201d8dd722b01da2f5fa46bf11ffcd1dbb402e.png" />
</div>
</div>
<p>Conversão de Projeção durante a Leitura</p>
<p>É possível reprojetar dados durante a leitura aplicando o método to_crs(), economizando um passo posterior de transformação.</p>
<p>Reprojetar dados de qualquer EPSG para o EPSG: 4674.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># gdf = gpd.read_file(&#39;caminho_do_arquivo.shp&#39;).to_crs(epsg=4674)</span>
</pre></div>
</div>
</div>
</div>
<p>Lendo com Codificação Específica</p>
<p>Ao trabalhar com dados geoespaciais, especialmente dados de diferentes fontes ou regiões, pode ser necessário experimentar ou verificar a documentação para determinar a codificação correta. Algumas codificações comuns incluem (quadro 9):</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Codificação</p></th>
<th class="head"><p>Descrição</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>UTF-8</p></td>
<td><p>Codificação Unicode popular que pode representar qualquer caractere no conjunto de caracteres Unicode. É a codificação padrão para muitos formatos de arquivo e é amplamente usada em aplicações web.</p></td>
</tr>
<tr class="row-odd"><td><p>ISO-8859-1</p></td>
<td><p>Codificação de um único byte que pode representar os primeiros 256 pontos de código Unicode. É comum em dados de países ocidentais. Também conhecido como Latin1.</p></td>
</tr>
<tr class="row-even"><td><p>CP1252</p></td>
<td><p>Uma codificação de página de código usada pelo Windows em inglês e em algumas outras línguas ocidentais.</p></td>
</tr>
<tr class="row-odd"><td><p>ISO-8859-15</p></td>
<td><p>Semelhante ao ISO-8859-1, mas inclui alguns caracteres adicionais, como o euro (€).</p></td>
</tr>
</tbody>
</table>
<p>Para corrigir o problema, vamos ler novamente o arquivo, especificando a codificação (parâmetro encoding) ISO-8859-1:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/7_capitais_CSV/capitais_brasil.csv&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;ISO-8859-1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Lendo dados não espaciais (tabulares)</p>
<p>O Geopandas é projetado para lidar com dados geoespaciais, mas, dado que é uma extensão do Pandas, também pode manipular dados tabulares (não espaciais). No entanto, para dados puramente tabulares, é mais comum e direto usar o Pandas.</p>
<p>Criando geometrias no Geopandas</p>
<p>No Geopandas, além de manipular e analisar dados geoespaciais, você também pode criar geometrias. Como vimos anteriormente, a biblioteca Shapely (que é uma dependência do Geopandas) fornece as ferramentas para criar e manipular geometrias. O Geopandas integra essas ferramentas para facilitar a criação e manipulação de geometrias dentro de seus GeoDataFrames e GeoSeries. Vamos estudar algumas funções e métodos para criar geometrias no Geopandas:</p>
<p>a) A partir de dados:</p>
<p>Se você tiver dados em um DataFrame do Pandas e quiser convertê-los em um GeoDataFrame com geometrias, pode usar a função Geopandas.GeoDataFrame.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;longitude&#39;</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mf">67.8270</span><span class="p">,</span> <span class="o">-</span><span class="mf">40.2976</span><span class="p">,</span> <span class="o">-</span><span class="mf">54.6156</span><span class="p">],</span> 
    <span class="s1">&#39;latitude&#39;</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mf">9.97499</span><span class="p">,</span> <span class="o">-</span><span class="mf">20.3195</span><span class="p">,</span> <span class="o">-</span><span class="mf">20.4428</span><span class="p">]})</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">latitude</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>A primeira linha desse código cria um DataFrame do Pandas chamado df, com base em um dicionário de dados. O dicionário tem duas chaves: ‘longitude’ e ‘latitude’. Cada chave está associada a uma lista de valores.</p>
<p>A segunda linha do código converte o DataFrame df em um GeoDataFrame gdf, adicionando informações geométricas (neste caso, pontos) a partir de duas colunas do DataFrame original que representam coordenadas de longitude e latitude. gpd.points_from_xy(df.longitude, df.latitude), points_from_xy cria uma série de objetos geométricos do tipo “ponto” a partir de duas sequências de valores: a primeira para as coordenadas X (longitudes) e a segunda para as coordenadas Y (latitudes). Assim, ela transforma pares de valores de longitude e latitude em pontos geométricos.</p>
<p>Em gpd.GeoDataFrame(df, geometry=…) criamos um novo GeoDataFrame a partir do DataFrame original df. O parâmetro geometry é usado para especificar qual coluna do GeoDataFrame deve ser tratada como a coluna de geometria. Ao fornecer a série de pontos criada no passo anterior como valor para o argumento geometry, estamos efetivamente adicionando uma nova coluna ao DataFrame original que armazenará as informações geométricas.</p>
<p>Para criar um shapefile com atributos e geometrias, a partir de um dicionário:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Point</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="c1"># Definição do dicionário</span>
<span class="n">capitais</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;Rio Branco&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;Acre&#39;</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mf">67.8270</span><span class="p">,</span> <span class="o">-</span><span class="mf">9.97499</span><span class="p">)),</span>
    <span class="s1">&#39;Vitória&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;Espírito Santo&#39;</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mf">40.2976</span><span class="p">,</span> <span class="o">-</span><span class="mf">20.3195</span><span class="p">)),</span>
    <span class="s1">&#39;Campo Grande&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;Mato Grosso do Sul&#39;</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mf">54.6156</span><span class="p">,</span> <span class="o">-</span><span class="mf">20.4428</span><span class="p">)),</span>
    <span class="s1">&#39;João Pessoa&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;Paraíba&#39;</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mf">34.8761</span><span class="p">,</span> <span class="o">-</span><span class="mf">7.11509</span><span class="p">)),</span>
    <span class="s1">&#39;Porto Alegre&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;Rio Grande do Sul&#39;</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mf">51.2167</span><span class="p">,</span> <span class="o">-</span><span class="mf">30.0277</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>Um dicionário chamado capitais é definido. As chaves desse dicionário são nomes de capitais de alguns estados brasileiros. Cada valor associado a uma capital é uma tupla contendo o nome do estado e outra tupla com as coordenadas geográficas (longitude e latitude) da capital.</p>
<p>O objetivo das próximas linhas de código é extrair informações separadas do dicionário capitais e armazená-las em listas individuais.</p>
<p>Convertendo o dicionário para listas separadas</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nomes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">capitais</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="n">estados</span> <span class="o">=</span> <span class="p">[</span><span class="n">capitais</span><span class="p">[</span><span class="n">capital</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">capital</span> <span class="ow">in</span> <span class="n">nomes</span><span class="p">]</span>
<span class="n">longitudes</span> <span class="o">=</span> <span class="p">[</span><span class="n">capitais</span><span class="p">[</span><span class="n">capital</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">capital</span> <span class="ow">in</span> <span class="n">nomes</span><span class="p">]</span>
<span class="n">latitudes</span> <span class="o">=</span> <span class="p">[</span><span class="n">capitais</span><span class="p">[</span><span class="n">capital</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">capital</span> <span class="ow">in</span> <span class="n">nomes</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>No código acima:</p>
<p>a) nomes = list(capitais.keys()) extrai os nomes das capitais (que são as chaves do dicionário) e os armazena em uma lista chamada nomes;</p>
<p>b) estados = <code class="docutils literal notranslate"><span class="pre">[capitais[capital][0]</span> <span class="pre">for</span> <span class="pre">capital</span> <span class="pre">in</span> <span class="pre">nomes]</span></code> é uma list comprehension que itera sobre cada capital na lista nomes e extrai o nome do estado associado (que é o primeiro elemento da tupla associada a cada capital no dicionário). O resultado é armazenado na lista estados.;</p>
<p>c) longitudes = <code class="docutils literal notranslate"><span class="pre">[capitais[capital][1][0]</span></code> for capital in nomes] extrai a longitude de cada capital (que é o primeiro elemento da segunda tupla associada a cada capital) e armazena os valores na lista longitudes.</p>
<p>d) latitudes = <code class="docutils literal notranslate"><span class="pre">[capitais[capital][1][1]</span> <span class="pre">for</span> <span class="pre">capital</span> <span class="pre">in</span> <span class="pre">nomes]</span></code> extrai a latitude de cada capital (que é o segundo elemento da segunda tupla associada a cada capital) e armazena os valores na lista latitudes.</p>
<p>O trecho de código abaixo cria um GeoDataFrame a partir das listas nomes, estados, longitudes e latitudes que foram previamente extraídas do dicionário capitais.</p>
<p>Criando um GeoDataFrame</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">({</span>
    <span class="s1">&#39;capital&#39;</span><span class="p">:</span> <span class="n">nomes</span><span class="p">,</span>
    <span class="s1">&#39;estado&#39;</span><span class="p">:</span> <span class="n">estados</span><span class="p">,</span>
    <span class="s1">&#39;geometry&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span> <span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">longitudes</span><span class="p">,</span> <span class="n">latitudes</span><span class="p">)]</span>
<span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<p>Nesse trecho:</p>
<p>a) gpd.GeoDataFrame() cria um novo GeoDataFrame chamado gdf;</p>
<p>b) ‘capital’: nomes e ‘estado’: estados são colunas que armazenam os nomes das capitais e dos estados, respectivamente, usando as listas nomes e estados;</p>
<p>c) ‘geometry’: <code class="docutils literal notranslate"><span class="pre">[Point(xy)</span> <span class="pre">for</span> <span class="pre">xy</span> <span class="pre">in</span> <span class="pre">zip(longitudes,</span> <span class="pre">latitudes)]</span></code> é a coluna de geometria do GeoDataFrame. A compreensão de lista dentro dessa linha cria uma lista de objetos Point a partir das listas longitudes e latitudes. A função zip() é usada para emparelhar cada longitude com sua latitude correspondente, e cada par é passado para o construtor Point() para criar um objeto geométrico do tipo ponto.</p>
<p>gdf.crs = ‘EPSG:4674’</p>
<p>A linha acima atribui o CRS SIRGAS 2000 ao GeoDataFrame gdf.</p>
<p>A partir de WKT (Well-Known Text)</p>
<p>O formato WKT, que significa Well-Known Text, é uma representação textual padrão para geometrias espaciais. Ele é usado para transmitir informações sobre objetos geométricos - como pontos, linhas e polígonos - de uma maneira legível por humanos e máquina.</p>
<p>O formato WKT é útil porque fornece uma maneira padrão e concisa de representar geometrias. Isso facilita a troca, armazenamento e análise de dados geoespaciais em diferentes sistemas e plataformas. Muitas ferramentas e bibliotecas geoespaciais, como PostGIS, QGIS, Shapely e Geopandas, suportam a leitura e escrita de geometrias no formato WKT.</p>
<p>Para criar um GeoDataFrame a partir de um WKT:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">GeometryCollection</span><span class="p">,</span> <span class="n">Point</span><span class="p">,</span> <span class="n">LineString</span>

<span class="n">geom_collection</span> <span class="o">=</span> <span class="n">GeometryCollection</span><span class="p">([</span><span class="n">Point</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> 
    <span class="n">LineString</span><span class="p">([(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">40</span><span class="p">)])])</span>
</pre></div>
</div>
</div>
</div>
<p>Escrevendo um GeoDataFrame para um arquivo no disco</p>
<p>Escrever um GeoDataFrame em um arquivo ou banco de dados é uma operação corriqueira ao trabalhar com dados geoespaciais no Geopandas. Aqui estão algumas das opções mais comuns:</p>
<p>Escrever em Shapefile:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/saida/capitais.shp&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Escrever em GeoJSON:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/saida/capitais.geojson&#39;</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="s1">&#39;GeoJSON&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Escrever em GeoPackage (GPKG):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/saida/capitais.gpkg&#39;</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="s1">&#39;GPKG&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<section id="funcoes-apply-map-e-replace-no-contexto-do-geopandas">
<h2>5.3 Funções apply, map e replace no contexto do Geopandas<a class="headerlink" href="#funcoes-apply-map-e-replace-no-contexto-do-geopandas" title="Permalink to this heading">#</a></h2>
<section id="a-funcao-apply-no-geopandas">
<h3>5.3.1 A função apply no Geopandas<a class="headerlink" href="#a-funcao-apply-no-geopandas" title="Permalink to this heading">#</a></h3>
<p>A função apply é uma herança do Pandas que permite aplicar uma determinada função a todos os elementos de uma coluna ou linha em um DataFrame ou GeoDataFrame. No Geopandas, essa função é comumente utilizada para realizar operações específicas em cada uma das geometrias de um conjunto de dados geoespacial. Vamos entender melhor com alguns exemplos.</p>
<p>Exemplo 1: Calcular o comprimento dos rios do estado do Maranhão apresentados na figura 35.</p>
<p>Etapa 1: Leitura do shapefile e edição do GeoDataFrame</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="n">gdf_rios</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/rios_maranhao.shp&#39;</span><span class="p">)</span>
<span class="n">gdf_rios</span> <span class="o">=</span> <span class="n">gdf_rios</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="s1">&#39;EPSG:31983&#39;</span><span class="p">)</span>
<span class="n">gdf_rios</span> <span class="o">=</span> <span class="n">gdf_rios</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;NORIOCOMP&#39;</span><span class="p">:</span> <span class="s1">&#39;nome&#39;</span><span class="p">})</span>
<span class="n">gdf_rios</span> <span class="o">=</span> <span class="n">gdf_rios</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;FID_GEOFT_&#39;</span><span class="p">,</span> 
    <span class="s1">&#39;CORIO&#39;</span><span class="p">,</span> <span class="s1">&#39;FID_BR_UF_&#39;</span><span class="p">,</span> <span class="s1">&#39;CD_UF&#39;</span><span class="p">,</span> <span class="s1">&#39;NM_UF&#39;</span><span class="p">,</span> <span class="s1">&#39;SIGLA_UF&#39;</span><span class="p">,</span> 
    <span class="s1">&#39;NM_REGIAO&#39;</span><span class="p">,</span> <span class="s1">&#39;AREA_KM2&#39;</span><span class="p">,</span> <span class="s1">&#39;Shape_Leng&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">CPLE_OpenFailedError</span><span class="g g-Whitespace">                      </span>Traceback (most recent call last)
<span class="nn">fiona/_shim.pyx</span> in <span class="ni">fiona._shim.gdal_open_vector</span><span class="nt">()</span>

<span class="nn">fiona/_err.pyx</span> in <span class="ni">fiona._err.exc_wrap_pointer</span><span class="nt">()</span>

<span class="ne">CPLE_OpenFailedError</span>: /home/alexandro/geopythonbook/content/rios_maranhao.shp: No such file or directory

<span class="n">During</span> <span class="n">handling</span> <span class="n">of</span> <span class="n">the</span> <span class="n">above</span> <span class="n">exception</span><span class="p">,</span> <span class="n">another</span> <span class="n">exception</span> <span class="n">occurred</span><span class="p">:</span>

<span class="ne">DriverError</span><span class="g g-Whitespace">                               </span>Traceback (most recent call last)
<span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">ipykernel_27372</span><span class="o">/</span><span class="mf">1576297623.</span><span class="n">py</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="g g-Whitespace">      </span><span class="mi">1</span> <span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="ne">----&gt; </span><span class="mi">2</span> <span class="n">gdf_rios</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/rios_maranhao.shp&#39;</span><span class="p">)</span>
<span class="g g-Whitespace">      </span><span class="mi">3</span> <span class="n">gdf_rios</span> <span class="o">=</span> <span class="n">gdf_rios</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="s1">&#39;EPSG:31983&#39;</span><span class="p">)</span>
<span class="g g-Whitespace">      </span><span class="mi">4</span> <span class="n">gdf_rios</span> <span class="o">=</span> <span class="n">gdf_rios</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;NORIOCOMP&#39;</span><span class="p">:</span> <span class="s1">&#39;nome&#39;</span><span class="p">})</span>
<span class="g g-Whitespace">      </span><span class="mi">5</span> <span class="n">gdf_rios</span> <span class="o">=</span> <span class="n">gdf_rios</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;FID_GEOFT_&#39;</span><span class="p">,</span> 

<span class="nn">~/anaconda3/lib/python3.9/site-packages/geopandas/io/file.py</span> in <span class="ni">_read_file</span><span class="nt">(filename, bbox, mask, rows, engine, **kwargs)</span>
<span class="g g-Whitespace">    </span><span class="mi">257</span> 
<span class="g g-Whitespace">    </span><span class="mi">258</span>     <span class="k">if</span> <span class="n">engine</span> <span class="o">==</span> <span class="s2">&quot;fiona&quot;</span><span class="p">:</span>
<span class="ne">--&gt; </span><span class="mi">259</span>         <span class="k">return</span> <span class="n">_read_file_fiona</span><span class="p">(</span>
<span class="g g-Whitespace">    </span><span class="mi">260</span>             <span class="n">path_or_bytes</span><span class="p">,</span> <span class="n">from_bytes</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">bbox</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="g g-Whitespace">    </span><span class="mi">261</span>         <span class="p">)</span>

<span class="nn">~/anaconda3/lib/python3.9/site-packages/geopandas/io/file.py</span> in <span class="ni">_read_file_fiona</span><span class="nt">(path_or_bytes, from_bytes, bbox, mask, rows, where, **kwargs)</span>
<span class="g g-Whitespace">    </span><span class="mi">301</span> 
<span class="g g-Whitespace">    </span><span class="mi">302</span>     <span class="k">with</span> <span class="n">fiona_env</span><span class="p">():</span>
<span class="ne">--&gt; </span><span class="mi">303</span>         <span class="k">with</span> <span class="n">reader</span><span class="p">(</span><span class="n">path_or_bytes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">as</span> <span class="n">features</span><span class="p">:</span>
<span class="g g-Whitespace">    </span><span class="mi">304</span>             <span class="n">crs</span> <span class="o">=</span> <span class="n">features</span><span class="o">.</span><span class="n">crs_wkt</span>
<span class="g g-Whitespace">    </span><span class="mi">305</span>             <span class="c1"># attempt to get EPSG code</span>

<span class="nn">~/anaconda3/lib/python3.9/site-packages/fiona/env.py</span> in <span class="ni">wrapper</span><span class="nt">(*args, **kwargs)</span>
<span class="g g-Whitespace">    </span><span class="mi">406</span>     <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="g g-Whitespace">    </span><span class="mi">407</span>         <span class="k">if</span> <span class="n">local</span><span class="o">.</span><span class="n">_env</span><span class="p">:</span>
<span class="ne">--&gt; </span><span class="mi">408</span>             <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">409</span>         <span class="k">else</span><span class="p">:</span>
<span class="g g-Whitespace">    </span><span class="mi">410</span>             <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>

<span class="nn">~/anaconda3/lib/python3.9/site-packages/fiona/__init__.py</span> in <span class="ni">open</span><span class="nt">(fp, mode, driver, schema, crs, encoding, layer, vfs, enabled_drivers, crs_wkt, **kwargs)</span>
<span class="g g-Whitespace">    </span><span class="mi">262</span> 
<span class="g g-Whitespace">    </span><span class="mi">263</span>         <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">):</span>
<span class="ne">--&gt; </span><span class="mi">264</span>             <span class="n">c</span> <span class="o">=</span> <span class="n">Collection</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="n">driver</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">265</span>                            <span class="n">layer</span><span class="o">=</span><span class="n">layer</span><span class="p">,</span> <span class="n">enabled_drivers</span><span class="o">=</span><span class="n">enabled_drivers</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">266</span>         <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span>

<span class="nn">~/anaconda3/lib/python3.9/site-packages/fiona/collection.py</span> in <span class="ni">__init__</span><span class="nt">(self, path, mode, driver, schema, crs, encoding, layer, vsi, archive, enabled_drivers, crs_wkt, ignore_fields, ignore_geometry, **kwargs)</span>
<span class="g g-Whitespace">    </span><span class="mi">160</span>             <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span>
<span class="g g-Whitespace">    </span><span class="mi">161</span>                 <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>
<span class="ne">--&gt; </span><span class="mi">162</span>                 <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">163</span>             <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">):</span>
<span class="g g-Whitespace">    </span><span class="mi">164</span>                 <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">WritingSession</span><span class="p">()</span>

<span class="nn">fiona/ogrext.pyx</span> in <span class="ni">fiona.ogrext.Session.start</span><span class="nt">()</span>

<span class="nn">fiona/_shim.pyx</span> in <span class="ni">fiona._shim.gdal_open_vector</span><span class="nt">()</span>

<span class="ne">DriverError</span>: /home/alexandro/geopythonbook/content/rios_maranhao.shp: No such file or directory
</pre></div>
</div>
</div>
</div>
<p>Etapa 2: Calcular o comprimento de cada rio e armazenar os resultados na nova coluna comprimento.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_rios</span><span class="p">[</span><span class="s1">&#39;comprimento&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_rios</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">geom</span><span class="p">:</span> <span class="n">geom</span><span class="o">.</span><span class="n">length</span><span class="p">)</span><span class="o">/</span><span class="mf">1e3</span>

<span class="n">Nesse</span> <span class="n">código</span><span class="p">,</span> <span class="n">utilizamos</span> <span class="n">o</span> <span class="n">método</span> <span class="n">apply</span><span class="p">()</span> <span class="n">para</span> <span class="n">aplicar</span> <span class="n">uma</span> <span class="n">função</span> <span class="n">a</span> <span class="n">cada</span> <span class="n">valor</span> <span class="n">na</span> <span class="n">coluna</span> <span class="n">geometry</span> <span class="n">do</span> <span class="n">GeoDataFrame</span> <span class="n">chamado</span> <span class="n">gdf_rios</span><span class="o">.</span> <span class="n">A</span> <span class="n">função</span> <span class="n">é</span> <span class="n">uma</span> <span class="n">função</span> <span class="k">lambda</span> <span class="n">que</span> <span class="n">pega</span> <span class="n">um</span> <span class="n">argumento</span> <span class="n">geom</span> <span class="p">(</span><span class="n">que</span> <span class="n">representa</span> <span class="n">uma</span> <span class="n">geometria</span> <span class="n">individual</span> <span class="n">da</span> <span class="n">coluna</span> <span class="n">geometry</span><span class="p">)</span> <span class="n">e</span> <span class="n">retorna</span> <span class="n">o</span> <span class="n">comprimento</span> <span class="n">dessa</span> <span class="n">geometria</span> <span class="n">usando</span> <span class="n">o</span> <span class="n">método</span> <span class="n">length</span><span class="o">.</span> <span class="n">Em</span> <span class="n">seguida</span><span class="p">,</span> <span class="n">dividimos</span> <span class="n">todos</span> <span class="n">os</span> <span class="n">comprimentos</span> <span class="n">por</span> <span class="mf">1e3</span> <span class="p">(</span><span class="n">que</span> <span class="n">é</span> <span class="n">igual</span> <span class="n">a</span> <span class="mi">1000</span><span class="p">)</span><span class="o">.</span> <span class="n">Isso</span> <span class="n">é</span> <span class="n">feito</span> <span class="n">para</span> <span class="n">converter</span> <span class="n">os</span> <span class="n">comprimentos</span> <span class="n">de</span> <span class="n">metros</span> <span class="n">para</span> <span class="n">quilômetros</span><span class="o">.</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">gdf_rios</span><span class="p">[[</span><span class="s1">&#39;nome&#39;</span><span class="p">,</span> <span class="s1">&#39;comprimento&#39;</span><span class="p">]])</span>
</pre></div>
</div>
</div>
</div>
<p>Exemplo 2: Inserir uma nova coluna no GeoDataFrame, cujo registro é o nome no rio e a sigla do estado. Por exemplo, Rio Pindaré MA.</p>
<p>Para processar ou transformar cada linha de um GeoDataFrame individualmente, utiliza-se a função apply com o argumento axis=1.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_rios</span><span class="p">[</span><span class="s1">&#39;UF&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;MA&#39;</span>
<span class="n">gdf_rios</span><span class="p">[</span><span class="s1">&#39;nome_UF&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_rios</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;nome&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;UF&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">gdf_rios</span> <span class="o">=</span> <span class="n">gdf_rios</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;nome&#39;</span><span class="p">,</span> <span class="s1">&#39;UF&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>No código acima, criamos a coluna ‘UF’ com o valor padrão ‘MA’, referente ao estado do Maranhão. Em seguida, aplicamos o apply com uma função lambda a cada linha (axis=1). A expressão da função lambda é <code class="docutils literal notranslate"><span class="pre">row['nome']</span> <span class="pre">+</span> <span class="pre">'</span> <span class="pre">'</span> <span class="pre">+</span> <span class="pre">row['UF'].</span></code> Aqui, para cada linha do GeoDataFrame, estamos concatenando o valor na coluna ‘nome’ com o valor na coluna ‘UF’, separados por um espaço. O resultado dessa concatenação é então atribuído à nova coluna ‘nome_UF’ para cada linha do GeoDataFrame. Por fim, deletamos as colunas ‘nome’ e ‘UF’.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="p">(</span><span class="n">gdf_rios</span><span class="p">[[</span><span class="s1">&#39;nome_UF&#39;</span><span class="p">,</span> <span class="s1">&#39;comprimento&#39;</span><span class="p">]])</span>
</pre></div>
</div>
</div>
</div>
<p>Exemplo 3: Criar um buffer de 30 metros em torno de cada rio que consta na figura x.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_rios</span><span class="p">[</span><span class="s1">&#39;buffer_app&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_rios</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">geom</span><span class="p">:</span> <span class="n">geom</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Nesse código utilizamos o método apply() para aplicar uma função a cada valor na coluna geometry. A função lambda pega um argumento geom (que representa uma geometria individual da coluna geometry) e aplica o método buffer(30) a ele. O método buffer(30) é um método do Shapely que cria um buffer (ou zona de influência) ao redor da geometria. Neste caso, o buffer terá uma distância de 30 metros a partir da geometria original.</p>
<p>Na figura x, temos uma visualização parcial das linhas originadas pela aplicação do buffer no Rio Grajaú.</p>
<p>Exemplo 4: Classificar os rios existentes no DataFrame em ‘pequeno’, ‘médio’ e ‘grande’.
Além de funções lambda, é possível criar as suas próprias funções e usá-las com apply.  Nesse exemplo, vamos criar a função ‘categoriza_comp’:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">categoriza_comp</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">row</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="mi">300000</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;pequeno&#39;</span>
    <span class="k">elif</span> <span class="n">row</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="mi">600000</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;médio&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;grande&#39;</span>
</pre></div>
</div>
</div>
</div>
<p>Essa função aceita um argumento chamado row, que é uma linha do GeoDataFrame. A linha if row.geometry.length &lt; 300000: verifica se o comprimento da geometria da linha atual é menor que 300.000 metros. Se a condição for verdadeira, a função retorna “pequeno”.
A linha elif row.geometry.length &lt; 600000: é avaliada se a primeira condição não for verdadeira. Verifica se o comprimento da geometria da linha atual é menor que 600.000 metros. Se essa condição for verdadeira, a função retorna “médio”. Se nenhuma das condições acima for verdadeira, a função retorna “grande”. As classes para essa função foram definidas aleatoriamente, sem uma base teórica, apenas para apresentar esse exemplo.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_rios</span><span class="p">[</span><span class="s1">&#39;categoria_comp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_rios</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">categoriza_comp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>No código acima, utilizamos o método apply() para aplicar a função categoriza_comp a cada linha do GeoDataFrame. O argumento axis=1 indica que a função será aplicada a cada linha.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">gdf_rios</span><span class="p">[[</span><span class="s1">&#39;nome_UF&#39;</span><span class="p">,</span> <span class="s1">&#39;categoria_comp&#39;</span><span class="p">]])</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="as-funcoes-map-e-replace-no-geopandas">
<h3>5.3.2 As funções map e replace no Geopandas<a class="headerlink" href="#as-funcoes-map-e-replace-no-geopandas" title="Permalink to this heading">#</a></h3>
<p>No Geopandas, assim como no Pandas, as funções map e replace oferecem meios distintos de transformar valores em uma coluna.
A função map é usada para substituir cada valor por outro valor, que pode ser derivado de uma função, dicionário ou uma Series. É particularmente útil quando se deseja realizar uma transformação elementar com base em um conjunto predefinido de correspondências. Por exemplo, se estiver trabalhando com um dicionário, você pode mapear códigos de estados para seus respectivos nomes completos. Contudo, é importante notar que a função map opera apenas sobre Series, e não sobre DataFrames inteiros.</p>
<p>Por outro lado, a função replace é mais geral e flexível. Ela permite substituir um valor por outro em um DataFrame ou Series. A substituição pode ter como base valores individuais ou listas de valores. Por exemplo, você pode usar replace para substituir todos os valores nulos ou específicos em um DataFrame por um valor padrão. Diferente do map, o replace não limita a substituição com base em um mapeamento direto, oferecendo uma abordagem mais abrangente para transformações.</p>
<p>Exemplo: Temos um arquivo shapefile com os municípios dos estados de Goiás, Mato Grosso e Mato Grosso do Sul (figura 37). No total, são 466 municípios. A identificação do estado a que cada município pertence se dá pela coluna SIGLA_UF, que armazena a sigla de cada estado. Queremos alterar a identificação dos estados de Goiás e Mato Grosso para os seus nomes ao invés das siglas, mas manter Mato Grosso do Sul identificado pela sua sigla. Vamos realizar essa operação usando tanto a função map quanto a função replace para compará-las.</p>
<p>a) utilizando a função map:</p>
<p>Inicialmente, criamos um GeoDataFrame a partir do arquivo shapefile mun_MT_MS_GO.shp.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span> <span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/mun_MT_MS_GO.shp&#39;</span><span class="p">)</span>
<span class="n">gdf</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mapeamento</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;GO&#39;</span><span class="p">:</span> <span class="s1">&#39;Goiás&#39;</span><span class="p">,</span> <span class="s1">&#39;MT&#39;</span><span class="p">:</span> <span class="s1">&#39;Mato Grosso&#39;</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>Na linha de código acima, criamos um dicionário chamado mapeamento (ele será útil em nossos próximos códigos). Neste dicionário, as siglas dos estados (como ‘GO’ e ‘MT’) são usadas como chaves, e os nomes completos dos estados (como ‘Goiás’ e ‘Mato Grosso’) são os valores correspondentes. Em termos práticos, isso significa que, se você acessar o valor associado à chave ‘GO’ no dicionário mapeamento, obterá ‘Goiás’. Da mesma forma, se acessar o valor associado à chave ‘MT’, obterá ‘Mato Grosso’.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_map</span> <span class="o">=</span> <span class="n">gdf</span>
<span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;SIGLA_UF&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;SIGLA_UF&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapeamento</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Neste código, a função map é aplicada à coluna ‘SIGLA_UF’. O que ela faz é mapear os valores desta coluna usando o dicionário mapeamento. Se um valor da coluna ‘SIGLA_UF’ corresponder a uma chave do dicionário, ele será substituído pelo valor associado no dicionário. Qualquer valor na coluna ‘SIGLA_UF’ que não estiver no dicionário mapeamento será convertido para NaN (ou seja, considerado como valor ausente). Saída:</p>
<p>Usando a função replace:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_rep</span> <span class="o">=</span> <span class="n">gdf</span>
<span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;SIGLA_UF&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;SIGLA_UF&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">mapeamento</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Neste segundo código, a função replace é aplicada à coluna ‘SIGLA_UF’ do GeoDataFrame gdf_rep. Semelhante à função map, a função replace substituirá os valores da coluna com base no dicionário mapeamento. No entanto, a diferença fundamental é que, com replace, se um valor da coluna ‘SIGLA_UF’ não estiver no dicionário mapeamento, ele permanecerá inalterado. Ou seja, replace não converte valores não mapeados para NaN.</p>
<p>Em resumo, enquanto tanto a função map quanto a função replace podem ser usadas para transformar valores com base em um dicionário de mapeamento, a função map irá converter valores não mapeados para NaN, enquanto a função replace deixará valores não mapeados inalterados.</p>
<p>5.4 Combinando DataFrames e GeoDataFrames</p>
<p>No âmbito da análise de dados geoespaciais, a combinação de DataFrames e GeoDataFrames é uma prática essencial para integrar e manipular informações de diferentes fontes. As ferramentas concat e merge, disponíveis em bibliotecas como pandas e geopandas, são amplamente utilizadas neste processo. Enquanto concat é utilizado para empilhar DataFrames verticalmente ou horizontalmente, respeitando o mesmo conjunto de colunas, a função merge é empregada para unir DataFrames com base em colunas específicas, similar a uma operação de junção em bancos de dados. Para melhor compreensão, exploraremos a aplicação dessas funções em detalhes utilizando dados reais a seguir.</p>
</section>
<section id="anexacao-metodo-concat">
<h3>5.4.1 Anexação: Método concat<a class="headerlink" href="#anexacao-metodo-concat" title="Permalink to this heading">#</a></h3>
<p>Exemplo: Temos cinco arquivos shapefile, um de cada região do Brasil (figura 38). Queremos criar um GeoDataFrame de todo o país.</p>
<p>Inicialmente, valos criar os GeoDataFrames de cada região a partir dos arquivos shapefile:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>

<span class="n">gdf_norte</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/norte.shp&#39;</span><span class="p">)</span>
<span class="n">gdf_sul</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/sul.shp&#39;</span><span class="p">)</span>
<span class="n">gdf_nordeste</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/nordeste.shp&#39;</span><span class="p">)</span>
<span class="n">gdf_sudeste</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/sudeste.shp&#39;</span><span class="p">)</span>
<span class="n">gdf_centro_oeste</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/centro_oeste.shp&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Em seguida, concatenamos todos os GeoDataFrames criados:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_brasil</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">gdf_norte</span><span class="p">,</span> <span class="n">gdf_sul</span><span class="p">,</span> <span class="n">gdf_nordeste</span><span class="p">,</span> 
    <span class="n">gdf_sudeste</span><span class="p">,</span> <span class="n">gdf_centro_oeste</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">gdf_brasil</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_brasil</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="juncoes-de-atributos-attribute-joins">
<h3>5.4.2 Junções de Atributos (Attribute Joins)<a class="headerlink" href="#juncoes-de-atributos-attribute-joins" title="Permalink to this heading">#</a></h3>
<p>Junções de atributos referem-se ao processo de combinar tabelas com base em valores de colunas comuns. Em termos de conjuntos de dados geoespaciais, isso significa que você pode combinar informações de diferentes fontes com base em um identificador comum, como um ID ou nome, sem considerar a localização geográfica. Esse tipo de junção é semelhante às junções realizadas em bancos de dados relacionais.
Inicialmente vamos importar as bibliotecas: Pandas (para manipulação de dados tabulares) e Geopandas (para manipulação de dados geoespaciais). Em seguida, vamos ler os dados e criar os DataFrames.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="n">gdf_cap</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/capitais_br.shp&#39;</span><span class="p">)</span>
<span class="n">df_censo_cap</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_excel</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/censo_capitais.xlsx&#39;</span><span class="p">)</span>

<span class="n">df_censo_cap</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_cap</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Agora vamos renomear as colunas do DataFrame df_censo_cap para torná-las mais descritivas:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#Alterar o nome das colunas do df_censo_cap</span>
<span class="n">df_censo_cap</span> <span class="o">=</span> <span class="n">df_censo_cap</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
    <span class="mi">2000</span><span class="p">:</span> <span class="s1">&#39;pop2000&#39;</span><span class="p">,</span>
    <span class="mi">2010</span><span class="p">:</span> <span class="s1">&#39;pop2010&#39;</span><span class="p">,</span>
    <span class="mi">2022</span><span class="p">:</span> <span class="s1">&#39;pop2022&#39;</span>
<span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<p>Vamos combinar gdf_cap e df_censo_cap com base na coluna codigo. A junção é do tipo “inner”, o que significa que apenas as linhas com códigos correspondentes em ambos os DataFrames serão inclusos no resultado.</p>
<p>Junção dos dataframes usando as colunas ‘capital’ e ‘Capital’</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_censo_cap</span> <span class="o">=</span> <span class="n">gdf_cap</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_censo_cap</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s1">&#39;codigo&#39;</span><span class="p">,</span> 
    <span class="n">right_on</span><span class="o">=</span><span class="s1">&#39;codigo&#39;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Nesse código, o método merge é usado para combinar DataFrames com base em colunas ou índices comuns. O parâmetro on=’codigo’ especifica que a combinação deve ser feita com base na coluna codigo. Em outras palavras, para cada linha em gdf_cap que tenha uma determinada sigla na coluna codigo, o método procurará por linhas em df_censo_cap que tenham a mesma sigla e combinará as informações.</p>
<p>O parâmetro how=’left’ define o tipo de junção a ser realizado. O valor ‘left’ significa que a junção é do tipo “left join”, ou seja, todas as linhas do gdf_cap serão mantidas. Caso não haja correspondência em df_censo_cap, os valores resultantes para as colunas de df_censo_cap serão NaN (valores faltantes).</p>
<p>Após a junção, temos duas colunas que representam a capital (uma de cada DataFrame). Esta linha remove uma delas.</p>
<p>Removendo a coluna ‘Capital’ duplicada após a junção</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_censo_cap</span> <span class="o">=</span> <span class="n">gdf_censo_cap</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Capital&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="selecao-e-filtragem-de-dados">
<h2>5.5 Seleção e filtragem de dados<a class="headerlink" href="#selecao-e-filtragem-de-dados" title="Permalink to this heading">#</a></h2>
<section id="selecao-com-base-em-atributos">
<h3>5.5.1 Seleção com base em atributos<a class="headerlink" href="#selecao-com-base-em-atributos" title="Permalink to this heading">#</a></h3>
<p>No Geopandas, a seleção com base em atributos refere-se ao processo de filtrar dados em um GeoDataFrame com base nos valores das colunas, similarmente ao que fazemos com o Pandas. Esse tipo de seleção permite que os usuários isolem subconjuntos específicos de dados com base em critérios definidos, como características geográficas, demográficas ou qualquer outro atributo tabular. Para exemplificar a seleção por atributos, vamos utilizar o GeoDataFrame gdf_uf_cp criado anteriormente.</p>
<p>Selecionar uma única coluna</p>
<p>Sintaxe básica:
<code class="docutils literal notranslate"><span class="pre">gdf['nome_da_coluna']</span></code></p>
<p>ou</p>
<p><code class="docutils literal notranslate"><span class="pre">gdf.nome_da_coluna</span></code></p>
<p>Exemplo: Selecionar a coluna ‘UF’, que armazena o nome dos estados brasileiros:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">estados</span><span class="o">=</span><span class="n">gdf_uf_cp</span><span class="p">[</span><span class="s1">&#39;UF&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Quando selecionamos apenas uma coluna, retorna uma Series.</p>
<p>Ao trabalhar com Geopandas, lembre-se de que se você remover a coluna “geometry”, o DataFrame (ou Series) resultante perderá sua natureza espacial e se tornará um DataFrame comum ou uma Series do Pandas.</p>
<p>Selecionar Múltiplas Colunas</p>
<p>Sintaxe básica:</p>
<p><code class="docutils literal notranslate"><span class="pre">gdf[['coluna1',</span> <span class="pre">'coluna2',</span> <span class="pre">'coluna3']]</span></code></p>
<p>Exemplo: selecionar as colunas UF, PIB_2020, Popul_2022 e geometry do GeoDataFrame</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_selecao</span> <span class="o">=</span> <span class="n">gdf_uf_cp</span><span class="p">[[</span><span class="s1">&#39;UF&#39;</span><span class="p">,</span> <span class="s1">&#39;PIB_2020&#39;</span><span class="p">,</span> <span class="s1">&#39;Popul_2022&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>
<span class="n">gdf_selecao</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Descartar Colunas</p>
<p>Ao invés de selecionar colunas específicas, você também pode descartar colunas que não deseja:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_drop</span> <span class="o">=</span> <span class="n">gdf_uf_cp</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;CD_UF&#39;</span><span class="p">,</span> <span class="s1">&#39;AREA_KM2&#39;</span><span class="p">])</span>
<span class="n">gdf_drop</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<section id="selecao-com-base-em-condicoes">
<h4>5.5.1.1 Seleção com base em Condições<a class="headerlink" href="#selecao-com-base-em-condicoes" title="Permalink to this heading">#</a></h4>
<p>A seleção baseada em condições é uma técnica comum ao trabalhar com DataFrames no Pandas e Geopandas. Ela permite filtrar linhas de um DataFrame com base em critérios específicos definidos por uma ou mais condições. Essa técnica é especialmente útil para análises exploratórias, pré-processamento de dados e muitas outras operações de manipulação de dados.</p>
<p>Sintaxe Básica:</p>
<p>A seleção baseada em condições é realizada usando uma expressão booleana dentro de colchetes.</p>
<p>Exemplo:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span> <span class="n">gdf</span><span class="p">[</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;coluna&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Exemplo: Criar o GeoDataFrame pop_menor_1M, com os estados brasileiros com população menor do que 1 milhão de habitantes em 2022:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pop_menor_1M</span> <span class="o">=</span> <span class="n">gdf_uf_cp</span><span class="p">[</span><span class="n">gdf_uf_cp</span><span class="p">[</span><span class="s1">&#39;Popul_2022&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">]</span>
<span class="n">pop_menor_1M</span><span class="o">.</span><span class="n">Head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Exemplo 2: Criar o GeoDataFrame pop_maior_20M, com os estados brasileiros cuja população era maior do que 20 milhões de habitantes em 2022:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pop_maior_20m</span> <span class="o">=</span> <span class="n">gdf_uf_cp</span><span class="p">[</span><span class="n">gdf_uf_cp</span><span class="p">[</span><span class="s1">&#39;Popul_2022&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">20000000</span><span class="p">]</span>
<span class="n">pop_maior_20m</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Selecionar a partir de Múltiplas Condições</p>
<p>Para aplicar múltiplas condições, é importante entender como combiná-las corretamente. Você pode usar operadores lógicos como “&amp;” (e), “|” (ou) e “ ~ ” (não) para combinar condições. Lembre-se de colocar cada condição entre parênteses.</p>
<p>Exemplo: Selecionar os estados brasileiros com mais de 10 milhões de habitantes em 2022 e PIB de 2020 menor que R$ 500 bilhões.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf_cp</span><span class="p">[(</span><span class="n">gdf_uf_cp</span><span class="p">[</span><span class="s1">&#39;Popul_2022&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">10000000</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">gdf_uf_cp</span><span class="p">[</span><span class="s1">&#39;PIB_2020&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">500000</span><span class="p">)]</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="o-metodo-query">
<h4>5.5.1.2 O Método query<a class="headerlink" href="#o-metodo-query" title="Permalink to this heading">#</a></h4>
<p>O método query permite escrever condições de seleção de forma mais legível, especialmente quando se lida com condições complexas. Por exemplo:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf_cp</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;Popul_2022 &gt; 10000000 &amp; PIB_2020 &lt; 500000&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Vamos realizar algumas consultas utilizando o método query.</p>
<p>Utilizando o operador OR</p>
<p>Selecionar os estados com mais de 15 milhões de habitantes em 2022 “OU” PIB de 2020 menor que R$ 1,6 trilhões.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf_cp</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;Popul_2022 &gt; 15000000 | PIB_2020 &gt; 1600000&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Operador NOT (~)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>	<span class="n">Selecionar</span> <span class="n">os</span> <span class="n">estados</span> <span class="n">cuja</span> <span class="n">população</span> <span class="n">não</span> <span class="n">era</span> <span class="n">maior</span> <span class="n">do</span> <span class="n">que</span> <span class="mi">1</span> <span class="n">milhão</span> <span class="n">no</span> <span class="n">censo</span> <span class="n">de</span> <span class="mi">2022</span><span class="p">:</span>
<span class="n">gdf_uf_cp</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;~(Popul_2022 &gt; 1000000)&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>O método isin</p>
<p>O método isin é útil para filtrar o DataFrame com base em uma lista de valores.</p>
<p>Sintaxe básica:</p>
<p><code class="docutils literal notranslate"><span class="pre">df[df['coluna'].isin(['valor1',</span> <span class="pre">'valor2'])]</span></code></p>
<p>Exemplo: Criar um GeoDataFrame com todos os estados que fazem parte das regiões Norte e Nordeste do Brasil, a partir do arquivo shapefile BR_UF.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="n">gdf_uf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/BR_UF.shp&#39;</span><span class="p">)</span>
<span class="n">norte_nordeste</span> <span class="o">=</span> <span class="n">gdf_uf</span><span class="p">[</span><span class="n">gdf_uf</span><span class="p">[</span><span class="s1">&#39;NM_REGIAO&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="s1">&#39;Norte&#39;</span><span class="p">,</span> <span class="s1">&#39;Nordeste&#39;</span><span class="p">])]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">norte_nordeste</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Seleção por rótulos e por posição</p>
<p>No Pandas e no Geopandas, a seleção de dados pode ser feita de várias maneiras, sendo as mais comuns a seleção por rótulos, por posição e por um único valor específico. Vamos entender a diferença entre esses métodos e exemplificar a partir GeoDataFrame gdf_uf_cp.</p>
<p>Seleção por Rótulos (loc)</p>
<p>O método loc é usado principalmente para selecionar com base em rótulos (nomes) de linhas e colunas. Pode aceitar rótulos de índices de linha e rótulos de colunas para retornar um subconjunto do DataFrame. Para obter o valor da coluna “A” na linha com índice “x”:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">valor</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Em que:</p>
<p>‘x’: É o rótulo da linha que você deseja acessar. Neste caso, você está tentando acessar a linha cujo rótulo (ou índice) é ‘x’.</p>
<p>‘A’: É o rótulo da coluna que você deseja acessar. Neste caso, você está tentando acessar a coluna chamada ‘A’.</p>
<p>O código <code class="docutils literal notranslate"><span class="pre">valor</span> <span class="pre">=</span> <span class="pre">df.loc['x',</span> <span class="pre">'A']</span></code> está pegando o dado registrado na linha com rótulo ‘x’ e na coluna com rótulo ‘A’ do DataFrame df e atribuindo esse dado à variável “valor”.</p>
<p>Vamos aplicar o loc em alguns exemplos em que queremos obter respostas no contexto dos estados do Brasil.</p>
<p>Inicialmente, vamos alterar o índice referente as linhas para a coluna “SIGLA_UF”. Assim poderemos usar a sigla referente a cada estado nas consultas.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf_cp</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;SIGLA_UF&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>GeoDataFrame com o índice alterado:</p>
<p>Consulta 1: Verificar a população em 2022 (Popul_2022) no estado da Paraíba.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf_cp</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span><span class="s1">&#39;Popul_2022&#39;</span><span class="p">]</span>
<span class="c1">#Saída: 3974495</span>
</pre></div>
</div>
</div>
</div>
<p>Consulta 2: Obter a geometria do estado da Paraíba.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf_cp</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;PB&#39;</span><span class="p">,</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Consulta 3: Obter os valores de PIB de 2020 (PIB_2020), População em 2000 (Popul_2000) e população em 2022 (Popul_2022) para o estado do Espírito Santo.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf_cp</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;ES&#39;</span><span class="p">,[</span><span class="s1">&#39;UF&#39;</span><span class="p">,</span> <span class="s1">&#39;PIB_2020&#39;</span><span class="p">,</span> <span class="s1">&#39;Popul_2000&#39;</span><span class="p">,</span> <span class="s1">&#39;Popul_2022&#39;</span><span class="p">]]</span>
</pre></div>
</div>
</div>
</div>
<p>Consulta 4: Selecionar todas as linhas de colunas específicas.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf_cp</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">[</span><span class="s1">&#39;CD_UF&#39;</span><span class="p">,</span> <span class="s1">&#39;UF&#39;</span><span class="p">,</span> <span class="s1">&#39;PIB_2020&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>
</pre></div>
</div>
</div>
</div>
<p>Consulta 5: Selecionar colunas específicas em um intervalo de linhas. Nesta consulta, vamos acessar os registros entre os estados de Sergipe e Santa Catarina.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf_cp</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;SE&#39;</span><span class="p">:</span><span class="s1">&#39;SC&#39;</span><span class="p">,[</span><span class="s1">&#39;UF&#39;</span><span class="p">,</span> <span class="s1">&#39;PIB_2020&#39;</span><span class="p">,</span> <span class="s1">&#39;Popul_2000&#39;</span><span class="p">,</span> <span class="s1">&#39;Popul_2022&#39;</span><span class="p">]]</span>
</pre></div>
</div>
</div>
</div>
<p>Seleção por Posição (iloc)</p>
<p>O método iloc é usado principalmente para seleção por posição inteira. Aceita somente valores inteiros que representam a posição do índice (linha) ou coluna.</p>
<p>Para exemplificar o iloc, inicialmente vamos resetar o índice do GeoDataFrame gpd_uf_cp para que ele fique indexado pela numeração original ao invés de SIGLA_UF:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf_cp</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Consulta 1: Obter o valor da primeira coluna (posição 0) na primeira linha (posição 0).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf_cp</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="c1"># Saída: 12 (registro da linha e coluna que estão </span>
<span class="c1"># na posição zero: primeiro registro da coluna CD_UF)</span>
</pre></div>
</div>
</div>
</div>
<p>Verificando no GeoDataFrame original:</p>
<p>Consulta 2: Obter os valores das duas primeiras colunas na primeira linha.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf_cp</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Consulta 3: Obter a geometria referente a segunda linha (índice 1) do GeoDataFrame (lembrando que é a coluna geometry que está no índice 3 das colunas)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf_cp</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Seleção de um Valor Específico (at)</p>
<p>O método at é semelhante ao loc, mas é usado para acessar um valor específico rapidamente. É mais rápido que loc quando você precisa acessar um único valor, mas não é adequado para selecionar múltiplos elementos.</p>
<p>Para obter o valor da coluna “A” na linha com índice “x”:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">valor</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Vamos alterar novamente o índice do GeoDataFrame para “SIGLA_UF”.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf_cp</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;SIGLA_UF&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Consulta 1: Selecionar a geometria referente ao estado do Mato Grosso.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf_cp</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="s1">&#39;MT&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Observações:</p>
<p>Embora at seja mais rápido para acessar um único valor, em operações mais complexas ou ao trabalhar com slices/subconjuntos, loc e iloc são geralmente mais versáteis.</p>
<p>Sempre tenha cuidado ao usar loc e iloc para modificar valores, pois você pode alterar inadvertidamente seu DataFrame se não especificar corretamente a linha e a coluna.</p>
<p>Lembre-se de que, ao trabalhar com GeoDataFrame, a coluna “geometry” contém as geometrias espaciais (por exemplo, pontos, linhas ou polígonos), e você pode acessar ou modificar essas geometrias da mesma maneira que outras colunas usando loc, iloc e at.</p>
<p>Seleção por Posição com iat:</p>
<p>O iat é um método rápido para acessar um valor escalar em um local específico em um DataFrame ou GeoDataFrame e é semelhante ao at. A principal diferença entre os dois é que iat é baseado em posições numéricas (como iloc), enquanto at é baseado em rótulos (como loc).</p>
<p>Vamos novamente resetar o índice do GeoDataFrame:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf_cp</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Consulta 1: Recuperar o registro que está armazenado na linha 23, coluna 3 do GeoDataFrame.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf_cp</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="mi">23</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Vantagens de usar iat:</p>
<p>Velocidade: O iat é otimizado para ser rápido ao acessar um único valor, tornando-o mais eficiente que iloc quando você precisa apenas de um valor escalar.</p>
<p>Simplicidade: É um método conciso para obter um valor rapidamente quando você sabe a posição numérica da linha e da coluna.</p>
<p>Cuidados ao usar iat:</p>
<p>Como iat é baseado em posições numéricas, é importante ter certeza de que você está referenciando a posição correta para evitar acessar dados errados.</p>
<p>Semelhante ao at, o iat é projetado para acessar um único valor de cada vez e não é adequado para operações que envolvem múltiplos valores ou slices.</p>
</section>
</section>
<section id="selecao-de-subconjuntos-via-coordenadas-bounding-box-com-notacao-slice">
<h3>5.5.2 Seleção de subconjuntos via coordenadas: bounding box com notação slice.<a class="headerlink" href="#selecao-de-subconjuntos-via-coordenadas-bounding-box-com-notacao-slice" title="Permalink to this heading">#</a></h3>
<p>Selecionar subconjuntos de dados com base em coordenadas é uma prática comum no Geopandas, especialmente quando se trabalha com grandes conjuntos de dados geoespaciais e se deseja focar em uma área específica. Uma das maneiras mais fáceis de fazer isso é usando uma bounding box (retângulo envolvente) com a notação de slice do Python, através do indexador cx.</p>
<p>Como vimos anteriormente, uma bounding box (caixa delimitadora) é geralmente representada por um retângulo definido por dois pontos: o canto inferior esquerdo e o canto superior direito. Em termos de coordenadas, você terá um par para o canto inferior esquerdo (mínimo de x, mínimo de y) e outro par para o canto superior direito (máximo de x, máximo de y):</p>
<p><code class="docutils literal notranslate"><span class="pre">gdf.cx[min_x:min_y,</span> <span class="pre">max_x:max_y]</span></code></p>
<p>Exemplo: Vamos supor que você tenha uma bounding box definida pelas coordenadas (-42, -12, -34, -2) (figura 44).</p>
<p>Para selecionar o subconjunto do GeoDataFrame “gdf_uf_cp” referente a esse bounding box:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">selecao</span> <span class="o">=</span> <span class="n">gdf_uf_cp</span><span class="o">.</span><span class="n">cx</span><span class="p">[</span><span class="o">-</span><span class="mi">34</span><span class="p">:</span><span class="o">-</span><span class="mi">42</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">12</span><span class="p">]</span>
<span class="n">selecao</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Lembre-se de garantir que o GeoDataFrame e a bounding box estejam no mesmo Sistema de Referência de Coordenadas (CRS) para obter resultados precisos. Se eles não estiverem, você precisará reprojetar o GeoDataFrame ou a bounding box para um CRS em comum antes de realizar a operação.</p>
</section>
</section>
<section id="operacoes-espaciais-no-geopandas">
<h2>5.6 Operações espaciais no Geopandas<a class="headerlink" href="#operacoes-espaciais-no-geopandas" title="Permalink to this heading">#</a></h2>
<p>Uma operação espacial refere-se a um conjunto de procedimentos ou métodos aplicados a objetos geométricos que produzem novas informações geoespaciais ou novas geometrias com base nas propriedades e relações espaciais dos objetos originais. Estas operações são fundamentais em sistemas de informação geográfica (SIG) e análise espacial, permitindo a obtenção de insights, a transformação de dados e resolução de problemas específicos do domínio espacial.</p>
<p>No Geopandas, estas operações são facilitadas pela integração com outras bibliotecas, como Shapely, para a manipulação de geometrias, e Fiona para a leitura e a escrita de arquivos. Dentre as operações espaciais mais comuns no Geopandas, podemos destacar:</p>
<p>Operações Métricas;</p>
<p>Operações de Transformação;</p>
<p>Operações de Generalização;</p>
<p>Operações de Decomposição;</p>
<p>Operações entre múltiplos GeoDataframes.</p>
<p>É importante ressaltar que a classificação mencionada acima pode variar de acordo com o contexto. Muitos métodos e funções no Geopandas podem se encaixar em múltiplas categorias de operações. Além disso, existem outras possíveis classificações e categorizações de operações que não serão abordadas em nosso curso.</p>
<section id="operacoes-metricas">
<h3>5.6.1 Operações métricas<a class="headerlink" href="#operacoes-metricas" title="Permalink to this heading">#</a></h3>
<p>As operações métricas em geoprocessamento e análise espacial referem-se a cálculos que produzem valores baseados em propriedades espaciais, como distâncias, áreas e comprimentos. Algumas das operações métricas disponíveis no Geopandas são apresentadas no quadro 10.</p>
<p>Quadro 10: Operações métricas no Geopandas.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Operação</p></th>
<th class="head"><p>Definição</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>area</p></td>
<td><p>Calcula a área de cada geometria em um GeoDataFrame ou GeoSeries.</p></td>
</tr>
<tr class="row-odd"><td><p>length</p></td>
<td><p>Calcula o comprimento de cada geometria. Isso é particularmente relevante para linhas ou polilinhas.</p></td>
</tr>
<tr class="row-even"><td><p>centroid</p></td>
<td><p>Calcula o ponto central (ou médio) de uma geometria.</p></td>
</tr>
<tr class="row-odd"><td><p>total_bounds</p></td>
<td><p>Retorna uma tupla com as coordenadas (minx, miny, maxx, maxy) que formam o retângulo envolvente ao redor do conjunto total de geometrias em um GeoDataFrame ou GeoSeries.</p></td>
</tr>
<tr class="row-even"><td><p>distance</p></td>
<td><p>Calcula a distância mínima entre as geometrias de dois GeoDataFrames ou GeoSeries.</p></td>
</tr>
</tbody>
</table>
<p>Vejamos alguns exemplos a seguir.</p>
<p>Cálculo de área:</p>
<p>Sintaxe básica:
<code class="docutils literal notranslate"><span class="pre">area</span> <span class="pre">=</span> <span class="pre">gdf['geometry'].area</span></code></p>
<p>Exemplo: Calcular a área do estado de Santa Catarina, utilizando o shapefile BR_UF.</p>
<p>Inicialmente vamos criar um GeoDataFrame a partir do arquivo shapefile, que tem os seguintes atributos:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf</span><span class="o">=</span><span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/BR_UF.shp&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Em seguida, selecionamos as colunas que irão compor nosso GeoDataFrame.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf</span> <span class="o">=</span> <span class="n">gdf_uf</span><span class="p">[[</span><span class="s1">&#39;NM_UF&#39;</span><span class="p">,</span> <span class="s1">&#39;SIGLA_UF&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>
</pre></div>
</div>
</div>
</div>
<p>A próxima etapa é filtrar o GeoDataFrame para incluir apenas as linhas em que NM_UF é igual a “Santa Catarina”:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_sc</span> <span class="o">=</span> <span class="n">gdf_uf</span><span class="p">[</span><span class="n">gdf_uf</span><span class="p">[</span><span class="s1">&#39;NM_UF&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Santa Catarina&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Agora, o GeoDataFrame gdf_sc contém apenas as linhas onde NM_UF é “Santa Catarina” e apenas as colunas NM_UF, SIGLA_UF e geometry.
Vamos verificar se o GeoDataFrame está em uma projeção apropriada para cálculos de área:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_sc</span><span class="o">.</span><span class="n">crs</span>
</pre></div>
</div>
</div>
</div>
<p>O GeoDataFrame está em um sistema de coordenadas geográficas. Para calcular a área, o ideal é que ele esteja em um sistema de coordenadas UTM. Vamos reprojetá-lo para o EPSG 31982 (SIRGAS UTM 22S).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_sc</span> <span class="o">=</span> <span class="n">gdf_sc</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">31982</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Por fim, calculamos a área (em km2) e insira como uma nova coluna. Lembre-se que, como o sistema de projeção está em UTM, a área será calculada em m2. Para armazenar a área em km2 em nosso GeoDataFrame, vamos dividir por 100.000 (1e6):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_sc</span><span class="p">[</span><span class="s1">&#39;AREA_KM2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_sc</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">area</span> <span class="o">/</span> <span class="mf">1e6</span>
</pre></div>
</div>
</div>
</div>
<p>Cálculo de comprimento:</p>
<p>Sintaxe básica:
<code class="docutils literal notranslate"><span class="pre">gdf['geometry'].length</span></code></p>
<p>Exemplo: Determinar o comprimento dos rios Araguaia e Tocantins, criando uma coluna ‘comprimento_M’ e inserindo os valores calculados.
Inicialmente criamos o GeoDataFrame e verificamos o sistema de coordenadas.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_rio</span><span class="o">=</span><span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/rios_arag_toc.shp&#39;</span><span class="p">)</span>
<span class="n">gdf_rio</span><span class="o">.</span><span class="n">crs</span>
</pre></div>
</div>
</div>
</div>
<p>Em seguida, alteramos o nome da coluna ‘NORIOCOMP’ para ‘nome’ e deletamos a coluna ‘CORIO’</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_rio</span> <span class="o">=</span> <span class="n">gdf_rio</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;NORIOCOMP&#39;</span><span class="p">:</span> <span class="s1">&#39;nome&#39;</span><span class="p">})</span>
<span class="n">gdf_rio</span> <span class="o">=</span> <span class="n">gdf_rio</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;CORIO&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>Agora vamos reprojetar para o EPSG 31982 (SIRGAS UTM 22S).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_rio</span> <span class="o">=</span> <span class="n">gdf_rio</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">31982</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Por fim, calculamos o comprimento (em km) e inserimos os valores como uma nova coluna.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_rio</span><span class="p">[</span><span class="s1">&#39;Comprimento_km&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_rio</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mf">1e3</span>
</pre></div>
</div>
</div>
</div>
<p>Cálculo do centroide</p>
<p>Sintaxe básica:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">centroides</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span>
</pre></div>
</div>
</div>
</div>
<p>Exemplo: Determinar os centroides dos estados do Brasil.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf</span><span class="p">[</span><span class="s1">&#39;centroid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_uf</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span>
</pre></div>
</div>
</div>
</div>
<p>Observação:</p>
<p>Quando você calcula o centroide em um CRS geográfico, o resultado será expresso em coordenadas de latitude e longitude. Esse centroide representa o “centro médio” das coordenadas da geometria. Ele provavelmente não será tão preciso quanto em um CRS projetado, especialmente para grandes áreas ou formas irregulares. Isso ocorre porque a distância entre graus de longitude varia com a latitude, e a superfície da Terra não é plana. Sendo assim, calcular o centroide em um CRS geográfico pode ser suficiente, especialmente se uma grande precisão não for necessária. No entanto, se você precisar de maior precisão, especialmente para grandes áreas, pode ser aconselhável transformar o GeoDataFrame para um CRS projetado antes de calcular o centroide.</p>
<p>Cálculo de distâncias</p>
<p>A função distance no Geopandas é usada para calcular a distância entre geometrias. Ela é aplicada a uma geometria e requer outra geometria como argumento para calcular a distância entre elas. A distância é calculada entre os pontos mais próximos das duas geometrias.</p>
<p>Exemplo: Calcular a distância (a menor distância) entre: a) Brasília e Palmas; b) Belém e Porto Alegre; c) Florianópolis e Goiânia.
A figura 47 destaca as capitais dos estados brasileiros que estão localizadas no fuso 22UTM (Optamos por selecionar apenas capitais que estão sob um mesmo fuso visando facilitar a demonstração da ferramenta).</p>
<p>Inicialmente, vamos ler o shapefile e criar o GeoDataFrame.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_cap</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/capitais_UTM22.shp&#39;</span><span class="p">)</span>
<span class="n">gdf</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Como o GeoDataFrame está em coordenadas geográficas, vamos reprojetá-lo para o EPSG 31982.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_cap</span> <span class="o">=</span> <span class="n">gdf_cap</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">31982</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Podemos verificar a mudança das coordenadas da coluna ‘geometry’.</p>
<p>Por fim, calculamos a distância entre capitais. Para tanto, vamos utilizar a seguinte sintaxe:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">distancia</span> <span class="o">=</span> <span class="p">(</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">capA</span><span class="p">])</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">capB</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>No código acima, <code class="docutils literal notranslate"><span class="pre">iloc[capA]</span> <span class="pre">e</span> <span class="pre">iloc[capB]</span></code> são as posições dos índices no GeoDataFrame das capitais que se está consultando. Por exemplo, a posição do índice de Brasilia é zero <code class="docutils literal notranslate"><span class="pre">(iloc[0])</span></code> e a de Palmas é seis <code class="docutils literal notranslate"><span class="pre">(iloc[6]).</span></code></p>
<p>Distância entre Brasília e Palmas</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">distancia</span> <span class="o">=</span> <span class="p">(</span><span class="n">gdf_cap</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">gdf_cap</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span><span class="o">/</span><span class="mf">1e3</span>
</pre></div>
</div>
</div>
</div>
<p>Distância entre Belém e Porto Alegre</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">distancia</span> <span class="o">=</span> <span class="p">(</span><span class="n">gdf_cap</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">gdf_cap</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span><span class="o">/</span><span class="mf">1e3</span>
</pre></div>
</div>
</div>
</div>
<p>#Distância entre Goiás e Florianópolis</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">distancia</span> <span class="o">=</span> <span class="p">(</span><span class="n">gdf_cap</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">gdf_cap</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span><span class="o">/</span><span class="mf">1e3</span>
</pre></div>
</div>
</div>
</div>
<p>total_bounds</p>
<p>O método total_bounds no Geopandas retorna uma tupla contendo as coordenadas do retângulo envolvente para todas as geometrias em um GeoSeries ou GeoDataFrame.</p>
<p>A tupla que retorna tem a seguinte estrutura:</p>
<p>(minx, miny, maxx, maxy)</p>
<p>minx e miny: São as coordenadas x e y do canto inferior esquerdo do retângulo delimitador;</p>
<p>maxx e maxy: São as coordenadas x e y do canto superior direito do retângulo delimitador.</p>
<p>Exemplo: verificar os limites do GeoDataFrame contendo a geometria do Brasil (DataFrame gdf_br):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">limites</span> <span class="o">=</span> <span class="n">gdf_br</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">total_bounds</span>
<span class="c1"># Saída: array([-73.99044997, -33.75117799, -28.84763991,   5.27184108])</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="operacoes-de-transformacao">
<h3>5.6.2 Operações de transformação<a class="headerlink" href="#operacoes-de-transformacao" title="Permalink to this heading">#</a></h3>
<p>Operações de transformação em geoprocessamento referem-se a métodos que alteram a posição, orientação, tamanho ou forma das geometrias, mas não necessariamente sua natureza intrínseca. Algumas das principais operações de transformação disponíveis no Geopandas estão no quadro 11.</p>
<p>Tabela 11: Operações de transformação no Geopandas.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Operação</p></th>
<th class="head"><p>Definição</p></th>
<th class="head"><p>Exemplo de Sintaxe</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>to_crs (reprojeção)</p></td>
<td><p>Altera o sistema de coordenadas das geometrias em um GeoDataFrame ou GeoSeries.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gdf.to_crs(epsg=4326)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>rotate</p></td>
<td><p>Rotaciona as geometrias por um ângulo determinado.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gdf.rotate(45)</span></code></p></td>
</tr>
<tr class="row-even"><td><p>scale</p></td>
<td><p>Redimensiona as geometrias multiplicando suas coordenadas por fatores de escala definidos.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gdf.scale(xfact=2.0,</span> <span class="pre">yfact=2.0)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>translate</p></td>
<td><p>Desloca as geometrias por uma quantidade definida em X e/ou Y.</p></td>
<td><p><code class="docutils literal notranslate"> <span class="pre">gdf.translate(xoff=10,</span> <span class="pre">yoff=20)</span></code></p></td>
</tr>
<tr class="row-even"><td><p>affine_transform</p></td>
<td><p>Aplica uma transformação afim às geometrias com base em uma matriz de transformação definida.</p></td>
<td><p><code class="docutils literal notranslate"> <span class="pre">gdf.affine_transform(matrix)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>simplify</p></td>
<td><p>Simplifica as geometrias, reduzindo o número de vértices, baseado no algoritmo Douglas-Peucker.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gdf.simplify(tolerance=0.01)</span></code></p></td>
</tr>
</tbody>
</table>
</section>
<section id="operacoes-de-generalizacao">
<h3>5.6.3 Operações de generalização<a class="headerlink" href="#operacoes-de-generalizacao" title="Permalink to this heading">#</a></h3>
<p>Generalização, no contexto da análise geoespacial, refere-se ao processo de simplificar representações geométricas, a fim de torná-las mais manejáveis, reduzir a complexidade, ou apresentar os dados em uma escala menor ou em um nível de detalhe mais amplo. As operações de generalização são especialmente úteis para visualização e otimização de desempenho. Algumas das principais operações de generalização disponíveis no Geopandas estão no quadro 12.</p>
<p>Quadro 12: Operações de generalização no Geopandas.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Operação</p></th>
<th class="head"><p>Definição</p></th>
<th class="head"><p>Exemplo de Sintaxe</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Convex_hull</p></td>
<td><p>Calcula o menor polígono convexo (envoltória convexa) que pode conter a geometria.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gdf.convex_hull</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>envelope</p></td>
<td><p>Produz uma caixa delimitadora retangular mínima para cada geometria.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gdf.envelope</span></code></p></td>
</tr>
<tr class="row-even"><td><p>dissolve</p></td>
<td><p>Combina várias geometrias em uma com base em uma coluna comum. Esta operação pode ser vista como uma forma de generalização porque pode consolidar várias entidades menores em uma única entidade maior.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gdf.dissolve(by='column_name')</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>simplify</p></td>
<td><p>Usa o algoritmo Douglas-Peucker (ou Visvalingam, se especificado) para simplificar as geometrias, reduzindo o número de vértices.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gdf.simplify(tolerance=0.01)</span></code></p></td>
</tr>
</tbody>
</table>
<p>Vamos aplicar o método dissolve no GeoDataFrame dos estados brasileiros, agregando os dados do censo de 2000, 2010 e 2022. Cada estado tem um nome, uma geometria e pertence a um país (no caso, o Brasil).</p>
<p>Inicialmente, vamos realizar algumas operações para criar um GeoDataFrame com os dados do PIB estadual de 2020 e dos Censos de 2000, 2010 e 2022 a partir de dado s que estão em planilhas do Excel.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
</pre></div>
</div>
</div>
</div>
<p>Ler o arquivo shapefile</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/BR_UF.shp&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Ler o arquivo Excel com dados do PIB estadual</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dfpib</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_excel</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/pibUfBr2020.xlsx&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Ler o arquivo Excel com dados do Censo de 2000, 2010 e 2022</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>dfcenso = pd.read_excel(&#39;/home/alexandro/geopythonbook/content/censo_UF.xlsx&#39;)```

Unindo os dataframes dfpib e dfcenso
```{code-cell} python
df_uf = pd.merge(dfpib, dfcenso, on=&#39;SIGLA_UF&#39;).drop(columns=&#39;UF_y&#39;).rename(columns={&#39;UF_x&#39;: &#39;UF&#39;})
</pre></div>
</div>
</div>
</div>
<p>Unindo o dataframe df_uf com o geodataframe</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf_cp</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_uf</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;SIGLA_UF&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;NM_UF&#39;</span><span class="p">,</span> <span class="s1">&#39;NM_REGIAO&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>Para aplicar o dissolve, precisamos de uma coluna com dados em comum para todos os registros (no caso, os estados). Com não temos essa coluna, vamos inserir uma coluna ‘pais’, com o valor default ‘br’.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf_cp</span><span class="p">[</span><span class="s1">&#39;pais&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;br&#39;</span>
<span class="n">gdf_uf_cp</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Agora que temos a coluna com um valor em comum para todos os estados podemos aplicar a função dissolve.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_br</span> <span class="o">=</span> <span class="n">gdf_uf_cp</span><span class="o">.</span><span class="n">dissolve</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;pais&#39;</span><span class="p">)</span>
<span class="n">gdf_br</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>A figura abaixo mostra a geometria antes (a) e após (b) a aplicação do método dissolve.</p>
<p>O resultado da operação dissolve terá a coluna usada para dissolver como índice. No exemplo acima, país se torna o índice do gdf_br. Se você não quiser que a coluna de dissolução se torne o índice, pode resetar o índice usando reset_index().</p>
<p>Podemos verificar que, embora a geometria tenha sido dissolvida, do ponto de vista dos atributos no GeoDataFrame, a operação eliminou os dados de todos os estados, deixando apenas os dados do primeiro registro, que era o estado do ACRE.</p>
<p>Além de combinar geometrias, a função dissolve também pode agregar dados associados a essas geometrias. Por padrão, todas as colunas (exceto a coluna usada para dissolver) tem seus valores agregados usando a função first, o que significa que apenas o primeiro valor encontrado é usado. No entanto, você pode especificar outras funções de agregação, como sum, mean, etc., para colunas específicas.</p>
<p>Para fazer com que a primeira linha contenha a soma das populações em todos os estados, para os anos de 2000, 2010 e 2022, além do PIB de 2020:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_br2</span> <span class="o">=</span> <span class="n">gdf_uf_cp</span><span class="o">.</span><span class="n">dissolve</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;pais&#39;</span><span class="p">,</span> <span class="n">aggfunc</span><span class="o">=</span><span class="p">{</span>
    <span class="s1">&#39;Popul_2000&#39;</span><span class="p">:</span> <span class="s1">&#39;sum&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Popul_2010&#39;</span><span class="p">:</span> <span class="s1">&#39;sum&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Popul_2022&#39;</span><span class="p">:</span> <span class="s1">&#39;sum&#39;</span><span class="p">,</span>
    <span class="s1">&#39;PIB_2020&#39;</span><span class="p">:</span> <span class="s1">&#39;sum&#39;</span>
    <span class="p">})</span>
<span class="n">gdf_br2</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="operacoes-de-decomposicao">
<h3>5.6.4 Operações de decomposição<a class="headerlink" href="#operacoes-de-decomposicao" title="Permalink to this heading">#</a></h3>
<p>Operações de decomposição, no contexto geoespacial, envolvem a quebra ou separação de geometrias complexas em componentes mais simples ou partes constituintes. Algumas das principais operações de decomposição disponíveis no Geopandas estão no quadro 13.</p>
<p>Quadro 13: Operações de decomposição no Geopandas.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Operação</p></th>
<th class="head"><p>Definição</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>boundary</p></td>
<td><p>Retorna uma representação das linhas externas de uma geometria. Por exemplo, para polígonos, isso resultará em linhas; para linhas, isso resultará em pontos nas extremidades.</p></td>
</tr>
<tr class="row-odd"><td><p>explode</p></td>
<td><p>Separa geometrias em suas múltiplas partes constituintes. Por exemplo, um Multipolygon será decomposto em vários polígonos individuais.</p></td>
</tr>
<tr class="row-even"><td><p>geometry (quando acessando componentes individuais)</p></td>
<td><p>Por exemplo, para uma Linestring, você pode acessar pontos individuais ou para um Polygon, você pode acessar seus anéis externo e interno.</p></td>
</tr>
</tbody>
</table>
<p>Boundary</p>
<p>O método boundary retorna uma representação geométrica das linhas de borda de uma geometria. Para um polígono, isso resultará em uma Linestring (ou Multilinestring para polígonos com furos) que representa o contorno do polígono. Ele não fornece uma medida, mas sim uma representação geométrica.
Sintaxe básica:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">contornos</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">boundary</span>
</pre></div>
</div>
</div>
</div>
<p>Exemplo: gerar a geometria de contorno do estado de Santa Catarina:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">contorno_sc</span> <span class="o">=</span> <span class="n">gdf_sc</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">boundary</span>
<span class="n">contorno_sc</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="operacoes-entre-multiplos-geodataframes">
<h3>5.6.5 Operações entre multiplos geodataframes<a class="headerlink" href="#operacoes-entre-multiplos-geodataframes" title="Permalink to this heading">#</a></h3>
<p>As operações entre múltiplos GeoDataFrames são uma parte crucial da análise geoespacial. Em muitos contextos, os dados geográficos são distribuídos em diferentes conjuntos ou fontes, e a capacidade de integrar, comparar ou realizar operações conjuntas entre esses conjuntos é fundamental. Como vimos, um GeoDataFrame é uma estrutura de dados que contém dados espaciais ou geográficos, como pontos, linhas e polígonos, juntamente com atributos.</p>
<p>Quando se trabalha com múltiplos GeoDataFrames, pode-se realizar uma série de operações, como união, interseção e diferença. Estas operações permitem combinar dados de diferentes fontes, identificar sobreposições ou discrepâncias entre conjuntos de dados e derivar novos insights ou conjuntos de dados a partir da combinação de dados existentes. Ao longo deste tópico, exploraremos possibilidades e técnicas para efetuar operações entre múltiplos GeoDataFrames.</p>
<section id="cortando-geometrias-com-a-ferramenta-clip">
<h4>5.6.5.1 Cortando Geometrias com a ferramenta Clip<a class="headerlink" href="#cortando-geometrias-com-a-ferramenta-clip" title="Permalink to this heading">#</a></h4>
<p>No contexto do geoprocessamento, o recorte é uma operação que permite extrair uma porção de uma geometria com base em outra. Esta técnica é corriqueira em análises espaciais onde é necessário isolar áreas específicas de interesse dentro de um conjunto de dados maior.</p>
<p>Ao realizar um recorte, obtém-se uma nova geometria que representa exatamente a área de intersecção entre as duas geometrias originais. No Python, a ferramenta clip é usada para realizar essa operação.</p>
<p>Exemplo: Gerar um GeoDataFrame com as rodovias de jurisdição federal no estado do Rio Grande do Sul.</p>
<p>Etapa 1. Importação do Geopandas, leitura dos arquivos shapefile e plotagem das rodovias federais do Brasil.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="n">gdf_rodo</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/rodovias_BR.shp&#39;</span><span class="p">)</span>
<span class="n">gdf_uf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/BR_UF.shp&#39;</span><span class="p">)</span>
<span class="n">gdf_rodo</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Etapa 2. Filtragem do estado desejado.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_RS</span> <span class="o">=</span> <span class="n">gdf_uf</span><span class="p">[</span><span class="n">gdf_uf</span><span class="p">[</span><span class="s1">&#39;SIGLA_UF&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;RS&#39;</span><span class="p">]</span>
<span class="n">gdf_RS</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Etapa 3. Verificação e Ajuste de CRS.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">gdf_rodo</span><span class="o">.</span><span class="n">crs</span> <span class="o">!=</span> <span class="n">gdf_RS</span><span class="o">.</span><span class="n">crs</span><span class="p">:</span>
    <span class="n">gdf_rodo</span> <span class="o">=</span> <span class="n">gdf_rodo</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">gdf_RS</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Etapa 4. Recortar a geometria.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rodovias_rs</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">gdf_rodo</span><span class="p">,</span> <span class="n">gdf_RS</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>A função clip do Geopandas é usada para recortar as rodovias usando a geometria do Rio Grande do Sul. O resultado é um novo GeoDataFrame, rodovias_rs, que contém apenas as rodovias de jurisdição federal (ou partes delas) localizadas dentro dos limites geográficos do RS.</p>
<p>Etapa 5. Visualização</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ax</span> <span class="o">=</span> <span class="n">gdf_RS</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">rodovias_rs</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="predicados-espaciais-uma-introducao">
<h4>5.6.5.2 Predicados Espaciais: Uma Introdução<a class="headerlink" href="#predicados-espaciais-uma-introducao" title="Permalink to this heading">#</a></h4>
<p>Predicados espaciais, também chamado de relações espaciais, são operadores que definem e descrevem relações entre objetos geométricos. No contexto da análise geoespacial, “predicado espacial” refere-se a uma função booleana que descreve uma relação entre duas geometrias. Retornam True ou False com base na relação espacial entre as geometrias.</p>
<p>Estes predicados são definidos pelo padrão “Simple Features” do Open Geospatial Consortium (OGC). O padrão estabelece uma linguagem comum e um conjunto de operações para manipulação e consulta de dados geométricos.</p>
<p>As bibliotecas geoespaciais, como shapely e Geopandas, implementam esses predicados espaciais, possibilitando a realização de consultas e análises espaciais complexas de maneira eficiente e intuitiva. Ao compreender e aplicar corretamente esses predicados, é possível extrair informações significativas de conjuntos de dados geoespaciais. Algumas das relações mais comuns descritas por predicados espaciais são apresentadas no quadro 11.</p>
<p>Quadro 14: Predicados espaciais.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Predicado Espacial</p></th>
<th class="head"><p>Conceito</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>contains</p></td>
<td><p>Verifica se uma geometria contém completamente a outra.</p></td>
</tr>
<tr class="row-odd"><td><p>within</p></td>
<td><p>Oposto de contains. Verifica se uma geometria está completamente dentro de outra.</p></td>
</tr>
<tr class="row-even"><td><p>touches</p></td>
<td><p>Verifica se duas geometrias têm, pelo menos, um ponto em comum, mas suas áreas não se sobrepõem.</p></td>
</tr>
<tr class="row-odd"><td><p>crosses</p></td>
<td><p>Verifica se duas geometrias têm alguma, mas não toda, área em comum.</p></td>
</tr>
<tr class="row-even"><td><p>intersects</p></td>
<td><p>Verifica se duas geometrias têm algum ponto em comum.</p></td>
</tr>
<tr class="row-odd"><td><p>disjoint</p></td>
<td><p>Verifica se duas geometrias não têm pontos em comum.</p></td>
</tr>
</tbody>
</table>
<p>Método contains</p>
<p>Sintaxe básica:</p>
<p><code class="docutils literal notranslate"><span class="pre">geometria1.contains(geometria2)</span></code></p>
<p>Exemplo: Verificar qual estado brasileiro contém o ponto referente a capital Cuiabá (figura 53). Para tanto, vamos utilizar dois GeoDataFrames, um com os polígonos referentes aos estados brasileiros e outro com os pontos referentes as suas capitais.</p>
<p>Inicialmente, vamos filtrar o GeoDataFrame ‘gdf_cap’ para encontrar a linha que tem ‘Cuiabá’ como capital.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">filtro_cuiaba</span> <span class="o">=</span> <span class="n">gdf_cap</span><span class="p">[</span><span class="s1">&#39;capital&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Cuiabá&#39;</span>
<span class="n">gdf_cuiaba</span> <span class="o">=</span> <span class="n">gdf_cap</span><span class="p">[</span><span class="n">filtro_cuiaba</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Em seguida, selecionamos a coluna ‘geometry’ desse GeoDataFrame filtrado.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">geometria_cuiaba</span> <span class="o">=</span> <span class="n">gdf_cuiaba</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Como sabemos que só existe uma capital chamada ‘Cuiabá’, pegamos o primeiro (e único) item dessa coluna.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ponto_cuiaba</span> <span class="o">=</span> <span class="n">geometria_cuiaba</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Agora, a variável ‘ponto_cuiaba’ contém as informações de latitude e longitude da capital Cuiabá. Por fim, utilizamos o método contains para verificar qual polígono contêm esse ponto.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">estado</span> <span class="o">=</span> <span class="n">gdf_uf</span><span class="p">[</span><span class="n">gdf_uf</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">ponto_cuiaba</span><span class="p">)]</span>
</pre></div>
</div>
</div>
</div>
<p>Método within</p>
<p>Sintaxe básica:</p>
<p><code class="docutils literal notranslate"><span class="pre">geometria1.within(geometria2)</span></code></p>
<p>Exemplo: Determinar quais pontos referentes as capitais dos estados brasileiros estão dentro do polígono referente ao estado de Roraima.</p>
<p>Inicialmente, vamos ler o arquivo shapefile, criar um GeoDataFrame e filtrar apenas as linhas em que ‘NM_UF’ é ‘Roraima’.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="n">gdf_uf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/BR_UF.shp&#39;</span><span class="p">)</span>
<span class="n">filtro_roraima</span> <span class="o">=</span> <span class="n">gdf_uf</span><span class="p">[</span><span class="s1">&#39;NM_UF&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Roraima&#39;</span>
<span class="n">gdf_roraima</span> <span class="o">=</span> <span class="n">gdf_uf</span><span class="p">[</span><span class="n">filtro_roraima</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Isso nos dará um novo GeoDataFrame com todos os atributos referentes ao estado de Roraima.</p>
<p>A partir do GeoDataFrame filtrado, selecionamos a coluna ‘geometry’</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">geometrias_roraima</span> <span class="o">=</span> <span class="n">gdf_roraima</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Essa operação resultará em uma Series com a geometria. Como temos apenas uma linha para Roraima, a Series terá apenas um item:</p>
<p>Vamos selecionar o primeiro (e único) item da série de geometrias</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">poligono_roraima</span> <span class="o">=</span> <span class="n">geometrias_roraima</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Agora, a variável poligono_roraima contém o polígono do estado de Roraima. Para verificar quais pontos referentes as capitais dos estados brasileiros estão dentro do polígono de Roraima, vamos utilizar o método within do Geopandas:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">capital_rr</span> <span class="o">=</span> <span class="n">gdf_cap</span><span class="p">[</span><span class="n">gdf_cap</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">within</span><span class="p">(</span><span class="n">poligono_roraima</span><span class="p">)]</span>
</pre></div>
</div>
</div>
</div>
<p>O resultado, capital_rr, é um GeoDataFrame contendo todos os registros de gdf_cap que estão dentro do polígono de Roraima.</p>
<p>Método intersects</p>
<p>Sintaxe básica:</p>
<p><code class="docutils literal notranslate"><span class="pre">geometria1.intersects(geometria2)</span></code></p>
<p>Exemplo: Determinar quais estados brasileiros são interseccionados pela rodovia BR-116 (figura56).</p>
<p>Inicialmente, vamos ler o arquivo shapefile referente a BR-116 e criar um GeoDataFrame. Iremos utilizar ainda o GeoDataFrame gdf_uf que carregamos anteriormente para exemplificar o método contains.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_br116</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/br116.shp&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Em seguida, selecionamos a geometria referente a BR-116. Como o GeoDataFrame gdf_linha_br116 possui apenas uma linha, expecificamos <code class="docutils literal notranslate"><span class="pre">iloc[0].</span></code></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">geometria_br116</span> <span class="o">=</span> <span class="n">gdf_br116</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Agora podemos verificar quais estados se interseccionam com a BR-116 utilizando o método intersects.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">estados_br116</span> <span class="o">=</span> <span class="n">gdf_uf</span><span class="p">[</span><span class="n">gdf_uf</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">geometria_br116</span><span class="p">)]</span>
</pre></div>
</div>
</div>
</div>
<p>Vamos imprimir os nomes desses estados, que podem ser visualizados na figura x.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">estados_br116</span><span class="p">[</span><span class="s1">&#39;NM_UF&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="diferentes-maneiras-de-utilizar-operacoes-e-predicados-espaciais-com-dois-ou-mais-geodataframes-no-contexto-do-geopandas">
<h4>5.6.5.3 Diferentes maneiras de utilizar operações e predicados espaciais com dois ou mais GeoDataFrames no contexto do Geopandas<a class="headerlink" href="#diferentes-maneiras-de-utilizar-operacoes-e-predicados-espaciais-com-dois-ou-mais-geodataframes-no-contexto-do-geopandas" title="Permalink to this heading">#</a></h4>
<p>Ao trabalhar com dados geoespaciais, é comum realizar operações que identificam e processam interações entre diferentes conjuntos de dados geográficos. A biblioteca Geopandas oferece várias funções e métodos para facilitar esse tipo de análise. Entretanto, à primeira vista, as funções podem parecer semelhantes em suas finalidades, levando a confusões sobre qual utilizar e quando.</p>
<p>Neste contexto, vamos explorar e comparar funcionalidades que relacionadas à interseção de geometrias: o intersects e o intersection no contexto do sjoin e do overlay. Para tanto, vamos criar dois GeoDataFrames (gdf1 e gdf2) a partir de operações de buffers em pontos que tem coordenadas x e y.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Point</span>

<span class="n">b1</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">.7</span><span class="p">)</span>
<span class="n">b2</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">.7</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;nome&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;PA&#39;</span><span class="p">,</span> <span class="s1">&#39;PB&#39;</span><span class="p">],</span>
    <span class="s1">&#39;valor&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span>
    <span class="s1">&#39;geometry&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">]</span>
<span class="p">}</span>
<span class="n">gdf1</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">b3</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">.7</span><span class="p">)</span>
<span class="n">b4</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">.7</span><span class="p">)</span>
<span class="n">data2</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;nome&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;PC&#39;</span><span class="p">,</span> <span class="s1">&#39;PD&#39;</span><span class="p">],</span>
    <span class="s1">&#39;valor&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span>
    <span class="s1">&#39;geometry&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">b3</span><span class="p">,</span> <span class="n">b4</span><span class="p">]</span>
<span class="p">}</span>
<span class="n">gdf2</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">data2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf1</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf2</span>
</pre></div>
</div>
</div>
</div>
<p>O código abaixo configura a visualização dos GeoDataFrames em uma única área de plotagem:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ax</span> <span class="o">=</span> <span class="n">gdf1</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">gdf2</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>mesmo codigo acima, mas para aparecer os nomes das geometrias</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ax</span> <span class="o">=</span> <span class="n">gdf1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">gdf2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Função para obter coordenadas representativas para anotação</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_coords</span><span class="p">(</span><span class="n">geom</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;Point&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">geom</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">y</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">geom</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span>
</pre></div>
</div>
</div>
</div>
<p>Adicionando anotações para gdf1</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">geom</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gdf1</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">gdf1</span><span class="p">[</span><span class="s1">&#39;nome&#39;</span><span class="p">]):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">get_coords</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Adicionando anotações para gdf2</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">geom</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gdf2</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">gdf2</span><span class="p">[</span><span class="s1">&#39;nome&#39;</span><span class="p">]):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">get_coords</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">label</span>
</pre></div>
</div>
</div>
</div>
<p>A visualização dos GeoDataFrames é apresentada na figura 61.</p>
<p>As circunferências PA e PB pertencem ao gdf1, enquanto PC e PD pertencem ao gdf2. A seguir, vamos utilizá-las em consultas espaciais.</p>
<p>a) Intersects</p>
<p>A função intersects do Geopandas determina se duas geometrias se interseccionam. É normalmente aplicada a uma GeoSeries e espera outra GeoSeries ou geometria como argumento. Vamos crias duas GeoSeries a partir dos GeoDataFrames gdf1 e gdf2.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gs1</span><span class="o">=</span><span class="n">gdf1</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
<span class="n">gs2</span><span class="o">=</span><span class="n">gdf2</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Agora aplicamos o intersects:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">resultado</span> <span class="o">=</span> <span class="n">gs1</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">gs2</span><span class="p">)</span>
<span class="n">resultado</span>
</pre></div>
</div>
</div>
</div>
<p>Este código verifica se cada geometria em gs1 tem interseção com alguma geometria em gs2. Retorna uma série booleana, com True em caso afirmativo e False caso contrário.</p>
<p>Vamos tentar visualizar o GeoDataFrame:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">resultado</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="c1"># Saída: TypeError: no numeric data to plot</span>
</pre></div>
</div>
</div>
</div>
<p>Como intersects resulta em uma Series de valores booleanos, não pode ser plotada diretamente.</p>
<p>b) Intersection</p>
<p>Intersection retorna uma nova GeoSeries com a geometria resultante da interseção entre gdf1 e gdf2. Uso comum: Obter a área ou parte da geometria onde dois conjuntos geoespaciais se sobrepõem.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cons_intersection</span> <span class="o">=</span> <span class="n">gdf1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">gdf2</span><span class="p">)</span>
<span class="n">cons_intersection</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cons_intersection</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>c) Intersects com Sjoin</p>
<p>Realiza uma junção espacial entre dois GeoDataFrames com base no predicado espacial Intersects. Retorna um novo GeoDataFrame resultante da junção dos GeoDataFrames nos locais em que suas geometrias se interseccionam. Este GeoDataFrame combinado terá colunas de ambos GeoDataFrames. Uso comum: Associar dados de um GeoDataFrame a outro com base em sua relação espacial, neste caso, interseção.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cons_int_sjoin</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span><span class="n">gdf1</span><span class="p">,</span> <span class="n">gdf2</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="s1">&#39;intersects&#39;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">)</span>
<span class="n">cons_int_sjoin</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Nesse código: a)  gpd.sjoin(…) é o método do Geopandas usado para realizar junções espaciais entre dois GeoDataFrames; b) op=’intersects’ especifica o tipo de relação espacial a ser verificada. Neste caso, estamos interessados em geometrias que se interseccionam (ou seja, têm pelo menos um ponto em comum); c) how=’inner’ especifica o tipo de junção a ser realizada. Uma junção “inner” retornará apenas as linhas onde houve uma correspondência. Em outras palavras, as linhas no resultado são apenas aquelas para as quais uma geometria em gdf1 intersecciona uma geometria em gdf2.</p>
<p>O código abaixo possibilita a plotagem do resultado da aplicação do sjoin.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="c1"># Plotar o GeoDataFrame &#39;join&#39;</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">cons_int_sjoin</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;whitesmoke&#39;</span><span class="p">)</span>
<span class="c1"># Anotar cada polígono com o valor da coluna &#39;nome_left&#39;</span>
<span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">label_left</span><span class="p">,</span> <span class="n">label_right</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cons_int_sjoin</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> 
    <span class="n">cons_int_sjoin</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">cons_int_sjoin</span><span class="p">[</span><span class="s1">&#39;nome_left&#39;</span><span class="p">],</span> 
    <span class="n">cons_int_sjoin</span><span class="p">[</span><span class="s1">&#39;nome_right&#39;</span><span class="p">]):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label_left</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> 
        <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset points&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label_right</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">15</span><span class="p">),</span> 
        <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset points&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Nessa operação, as geometrias originais de gdf1 são preservadas (figura x). Contudo, informações adicionais de gdf2 são anexadas às linhas correspondentes de gdf1 onde ocorre a interseção. Especificamente, os polígonos “PC” e “PD” de gdf2 tem interseção com as geometrias “PA” e “PB” de gdf1, respectivamente. Portanto, o novo GeoDataFrame, cons_int_sjoin, combina os atributos dessas geometrias em linhas unificadas, mantendo a estrutura original de gdf1 e incorporando informações relevantes de gdf2 onde as interseções ocorrem.
Vamos aplicar novamente o sjoin, mas invertendo a ordem dos GeoDataFrames:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cons_int_sjoin2</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span><span class="n">gdf2</span><span class="p">,</span> <span class="n">gdf1</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="s1">&#39;intersects&#39;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">)</span>
<span class="n">cons_int_sjoin2</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Note que, agora, as geometrias originais de gdf2 que são preservadas (figura x). Contudo, informações adicionais de gdf1 são anexadas às linhas correspondentes de gdf2 onde ocorre a interseção. Especificamente, os polígonos “PA” e “PB” de gdf1 tem interseção com as geometrias “PC” e “PD” de gdf2, respectivamente. Portanto, o novo GeoDataFrame, cons_int_sjoin2, combina os atributos dessas geometrias em linhas unificadas, mantendo a estrutura original de gdf2 e incorporando informações relevantes de gdf1 onde as interseções ocorrem.</p>
<p>d) Intersection com operação de Overlay</p>
<p>Essa operação calcula a interseção geométrica entre dois GeoDataFrames e combina os seus atributos. Retorna um novo GeoDataFrame cujas geometrias são a interseção entre as geometrias no GeoDataFrame 1 e no GeoDataFrame 2. Este GeoDataFrame combinado terá colunas de ambos.
Uso comum: Semelhante à operação intersection, mas mantém informações (atributos) de ambas as camadas geoespaciais.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cons_int_overlay</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">overlay</span><span class="p">(</span><span class="n">gdf1</span><span class="p">,</span> <span class="n">gdf2</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;intersection&#39;</span><span class="p">)</span>
<span class="n">cons_int_overlay</span>
</pre></div>
</div>
</div>
</div>
<p>Nesse código, gpd.overlay(…) é o método do Geopandas usado para realizar operações de sobreposição espacial entre dois GeoDataFrames. gdf1 e gdf2: São os dois GeoDataFrames que estão sendo combinados. A operação compara cada geometria em gdf1 com cada geometria em gdf2. how=’intersection’ especifica o tipo de operação de sobreposição a ser realizada. A opção “intersection” retorna a interseção geométrica entre as geometrias dos dois GeoDataFrames. Isso significa que a geometria resultante é aquela que é compartilhada entre gdf1 e gdf2 (figuras 65 e 66).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ax</span> <span class="o">=</span> <span class="n">cons_int_overlay</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;whitesmoke&#39;</span><span class="p">)</span>

<span class="c1"># Anotar cada polígono com o valor da coluna &#39;nome_left&#39;</span>
<span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">label_left</span><span class="p">,</span> <span class="n">label_right</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cons_int_overlay</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
    <span class="n">cons_int_overlay</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">cons_int_overlay</span><span class="p">[</span><span class="s1">&#39;nome_1&#39;</span><span class="p">],</span> <span class="n">cons_int_overlay</span><span class="p">[</span><span class="s1">&#39;nome_2&#39;</span><span class="p">]):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label_left</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset points&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label_right</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">15</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset points&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Diferente do sjoin, que mantém as geometrias originais de um dos GeoDataFrames e apenas anexa os atributos do outro onde há interseção, o overlay cria geometrias resultantes da interseção real entre as geometrias dos dois GeoDataFrames. Além disso, o novo GeoDataFrame resultante também combina os atributos das geometrias originais de gdf1 e gdf2 para cada uma dessas novas geometrias de interseção. Assim, cons_int_overlay fornece uma representação espacial precisa de onde as geometrias de gdf1 e gdf2 se cruzam, juntamente com os atributos combinados dessas interseções.</p>
<p>Agora vamos inverter a ordem de entrada dos GeoDataFrames na consulta:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cons_int_overlay2</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">overlay</span><span class="p">(</span><span class="n">gdf2</span><span class="p">,</span> <span class="n">gdf1</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;intersection&#39;</span><span class="p">)</span>
<span class="n">cons_int_overlay2</span>
</pre></div>
</div>
</div>
</div>
<p>Podemos verificar que, em termos de geometria, a interseção entre gdf1 e gdf2 será a mesma que a interseção entre gdf2 e gdf1. No entanto, a ordem dos atributos no resultado é diferente. Enquanto cons_int_overlay tem os atributos de gdf1 seguidos pelos de gdf2 para cada geometria de interseção, cons_int_overlay2 tem os atributos de gdf2 seguidos pelos de gdf1. Desta maneira, é possível concluir que a ordem em que GeoDataFrames são fornecidos ao método overlay influenciam a ordem dos atributos no GeoDataFrame resultante, mas não a geometria da interseção.</p>
<p>Conclusões:</p>
<p>Intersects é usado para verificar a interseção sem realmente computar a geometria resultante;</p>
<p>Intersection computa a geometria resultante da interseção;</p>
<p>Intersects com Sjoin: Mantém os registros do GeoDataFrame à esquerda (primeiro mencionado na operação) que têm alguma interseção com os registros do GeoDataFrame à direita. As geometrias do GeoDataFrame à esquerda são mantidas intactas. Não são alteradas para representar a interseção em si;</p>
<p>Intersection com Overlay: Cria registros que representam a interseção geométrica entre os registros dos dois GeoDataFrames fornecidos. As geometrias resultantes são as áreas de interseção entre os registros dos dois GeoDataFrames. Ou seja, são as partes que os registros dos dois GeoDataFrames têm em comum.</p>
</section>
<section id="juncoes-espaciais-spatial-joins">
<h4>5.6.5.4 Junções Espaciais (Spatial Joins)<a class="headerlink" href="#juncoes-espaciais-spatial-joins" title="Permalink to this heading">#</a></h4>
<p>A junção espacial (Sjoin) é uma ferramenta que permite a combinação de informações de dois GeoDataFrames com base em suas relações espaciais. Vimos uma aplicação dessa ferramenta no tópico anterior. Vamos agora aprofundar nosso estudo.</p>
<p>Os parâmetros principais em uma Sjoin são:</p>
<p>how: Tipo de junção a ser realizada. Pode ser uma das seguintes opções: “left”, “right” ou “inner”.</p>
<p>op: Operação espacial a ser usada. As opções são: “contains”, “within” e “intersects”.</p>
<p>O parâmetro how em sjoin (e em muitas outras operações de junção em bibliotecas como Pandas) determina como as linhas dos dois GeoDataFrames serão combinadas com base na relação espacial especificada. Ele especifica qual tipo de junção será realizado. Vamos analisar cada uma das opções:</p>
<p>“left” (junção à esquerda): Mantém todas as linhas do GeoDataFrame à esquerda, independentemente de haver uma correspondência no GeoDataFrame à direita. As linhas que não têm correspondência no GeoDataFrame à direita terão NaN (valor ausente) para todas as colunas desse GeoDataFrame;</p>
<p>“right” (junção à direita): Mantém todas as linhas do GeoDataFrame à direita, independentemente de haver uma correspondência no GeoDataFrame à esquerda. As linhas que não têm correspondência no GeoDataFrame à esquerda terão NaN para todas as colunas desse GeoDataFrame;</p>
<p>“inner” (junção interna): Mantém apenas as linhas para as quais há uma correspondência entre os dois GeoDataFrames. Ou seja, as linhas no resultado só estarão presentes se houver uma relação espacial válida entre elas (por exemplo, um ponto está dentro de um polígono) em ambos os conjuntos de dados. Linhas sem correspondência em qualquer GeoDataFrame serão descartadas.</p>
<p>Se pensarmos nos GeoDataFrames como se fossem tabelas. As opções “left”, “right” e “inner” determinam quais linhas (registros) dessas tabelas estarão presentes no resultado, após a operação de junção. Se você estiver familiarizado com bancos de dados SQL, esses conceitos de junção à esquerda, à direita e interna são semelhantes aos LEFT JOIN, RIGHT JOIN e INNER JOIN, respectivamente.</p>
<p>Exemplo: Temos um arquivo shapefile com pontos representando as usinas hidrelétricas e as PCHs (Pequenas Centrais Hidrelétricas) do Brasil (figura67). Queremos descobrir em qual estado brasileiro está localizada cada uma delas e inserir essa informação em arquivo.
Para resolver esse exemplo, vamos aplicar o sjoin com o predicado espacial ‘intersects’ entre dois GeoDataFrames: o das usinas e PCHs e o dos estados brasileiros.</p>
<p>Inicialmente, vamos ler os arquivos shapefile e criar os GeoDataFrames. Em seguida, verificamos as colunas existentes em gdf_usinas e gdf_uf.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="n">gdf_usinas</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/home/alexandro/geopythonbook/content/hidreletricas.shp&#39;</span><span class="p">)</span>
<span class="n">gdf_uf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/content/BR_UF.shp&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">gdf_usinas</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf</span><span class="o">.</span><span class="n">columns</span>
</pre></div>
</div>
</div>
</div>
<p>Vamos deletar algumas colunas de gdf_uf que não utilizaremos.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gdf_uf</span> <span class="o">=</span> <span class="n">gdf_uf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;CD_UF&#39;</span><span class="p">,</span> <span class="s1">&#39;NM_UF&#39;</span><span class="p">,</span> <span class="s1">&#39;AREA_KM2&#39;</span><span class="p">])</span>
<span class="n">gdf_uf</span><span class="o">.</span><span class="n">columns</span>
</pre></div>
</div>
</div>
</div>
<p>Para nos certificarmos de que ambos os GeoDataFrames estarão no mesmo CRS:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">gdf_usinas</span><span class="o">.</span><span class="n">crs</span> <span class="o">!=</span> <span class="n">gdf_uf</span><span class="o">.</span><span class="n">crs</span><span class="p">:</span>
    <span class="n">gdf_usinas</span> <span class="o">=</span> <span class="n">gdf_usinas</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">gdf_uf</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Esse código verifica se os dois GeoDataFrames têm CRSs diferentes. Em caso afirmativo, aplica uma transformação em gdf_usinas para corresponder ao CRS de gdf_uf.</p>
<p>Agora vamos aplicar a junção espacial.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">usinas_uf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span><span class="n">gdf_usinas</span><span class="p">,</span> <span class="n">gdf_uf</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="s1">&#39;intersects&#39;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
<span class="n">usinas_uf</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Esse código associa cada usina ao estado ao qual ela está localizada e consulta as colunas do GeoDataFrame.</p>
<p>Podemos verificar que, agora, o GeoDataFrame usinas_uf tem colunas referentes aos estados (SIGLA_UF E NM_REGIAO).
Vamos verificar quantas usinas e PCHs estão implantadas em cada estado.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">numero_usinas_por_estado</span> <span class="o">=</span> <span class="n">usinas_uf</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;SIGLA_UF&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">numero_usinas_por_estado</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Por fim, vamos agrupar os dados por região (NM_REGIAO) e imprimir o número de usinas em cada região do país.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">numero_usinas_por_regiao</span> <span class="o">=</span> <span class="n">usinas_uf</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;NM_REGIAO&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">numero_usinas_por_regiao</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="operacoes-de-conjunto-com-sobreposicao-overlay">
<h4>5.6.5.5 Operações de conjunto com sobreposição (overlay)<a class="headerlink" href="#operacoes-de-conjunto-com-sobreposicao-overlay" title="Permalink to this heading">#</a></h4>
<p>As operações de sobreposição, ou “overlay”, desempenham um importante papel no geoprocessamento, permitindo a combinação de diferentes camadas de dados para extrair, comparar e analisar relações geoespaciais. Na seção anterior, exploramos o overlay com a operação básica de interseção. Nesta seção, aprofundaremos nosso estudo, examinando outras operações de conjunto disponíveis.</p>
<p>Vamos aplicar cada uma delas no conjunto de dados utilizado na seção anterior: os GeoDataFrames gdf1 (polígonos PA e PB) e gdf 2 (polígonos PC e PD):</p>
<p>Overlay com union</p>
<p>Essa operação combina as geometrias dos dois conjuntos de dados. Isso inclui todas as áreas de ambos os conjuntos de dados, independentemente de se sobreporem ou não.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">uniao</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">overlay</span><span class="p">(</span><span class="n">gdf1</span><span class="p">,</span> <span class="n">gdf2</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;union&#39;</span><span class="p">)</span>
<span class="n">uniao</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">uniao</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Overlay com difference</p>
<p>Essa operação retorna as geometrias do primeiro conjunto de dados que não são compartilhadas com o segundo conjunto de dados. Em outras palavras, remove as áreas do segundo conjunto de dados que se sobrepõem ao primeiro.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">diferenca</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">overlay</span><span class="p">(</span><span class="n">gdf1</span><span class="p">,</span> <span class="n">gdf2</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;difference&#39;</span><span class="p">)</span>
<span class="n">diferenca</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">diferenca</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Fazendo gdf2 a esquerda e gdf1 a direita:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">diferenca2</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">overlay</span><span class="p">(</span><span class="n">gdf2</span><span class="p">,</span> <span class="n">gdf1</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;difference&#39;</span><span class="p">)</span>
<span class="n">diferenca2</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Overlay com symmetric_difference</p>
<p>Essa operação retorna as geometrias que são exclusivas para cada um dos conjuntos de dados. É o oposto da interseção, mantendo apenas as áreas que não se sobrepõem.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">diferenca_simetrica</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">overlay</span><span class="p">(</span><span class="n">gdf1</span><span class="p">,</span> <span class="n">gdf2</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;symmetric_difference&#39;</span><span class="p">)</span>
<span class="n">diferenca_simetrica</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">diferenca_simetrica</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Overlay com identity</p>
<p>Essa operação mantém as geometrias do primeiro conjunto de dados que se sobrepõem ao segundo conjunto de dados, bem como qualquer parte do primeiro conjunto de dados que não se sobrepõe ao segundo.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">identidade</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">overlay</span><span class="p">(</span><span class="n">gdf1</span><span class="p">,</span> <span class="n">gdf2</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;identity&#39;</span><span class="p">)</span>
<span class="n">identidade</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">identidade</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  <!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="capitulo4.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">4. GEOPROCESSAMENTO BÁSICO COM SHAPELY E FIONA</p>
      </div>
    </a>
    <a class="right-next"
       href="capitulo6.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">6. VISUALIZAÇÃO DE DADOS GEOESPACIAIS NO PYTHON</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#funcoes-apply-map-e-replace-no-contexto-do-geopandas">5.3 Funções apply, map e replace no contexto do Geopandas</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#a-funcao-apply-no-geopandas">5.3.1 A função apply no Geopandas</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#as-funcoes-map-e-replace-no-geopandas">5.3.2 As funções map e replace no Geopandas</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#anexacao-metodo-concat">5.4.1 Anexação: Método concat</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#juncoes-de-atributos-attribute-joins">5.4.2 Junções de Atributos (Attribute Joins)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#selecao-e-filtragem-de-dados">5.5 Seleção e filtragem de dados</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#selecao-com-base-em-atributos">5.5.1 Seleção com base em atributos</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#selecao-com-base-em-condicoes">5.5.1.1 Seleção com base em Condições</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#o-metodo-query">5.5.1.2 O Método query</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#selecao-de-subconjuntos-via-coordenadas-bounding-box-com-notacao-slice">5.5.2 Seleção de subconjuntos via coordenadas: bounding box com notação slice.</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#operacoes-espaciais-no-geopandas">5.6 Operações espaciais no Geopandas</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operacoes-metricas">5.6.1 Operações métricas</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operacoes-de-transformacao">5.6.2 Operações de transformação</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operacoes-de-generalizacao">5.6.3 Operações de generalização</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operacoes-de-decomposicao">5.6.4 Operações de decomposição</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operacoes-entre-multiplos-geodataframes">5.6.5 Operações entre multiplos geodataframes</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#cortando-geometrias-com-a-ferramenta-clip">5.6.5.1 Cortando Geometrias com a ferramenta Clip</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#predicados-espaciais-uma-introducao">5.6.5.2 Predicados Espaciais: Uma Introdução</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#diferentes-maneiras-de-utilizar-operacoes-e-predicados-espaciais-com-dois-ou-mais-geodataframes-no-contexto-do-geopandas">5.6.5.3 Diferentes maneiras de utilizar operações e predicados espaciais com dois ou mais GeoDataFrames no contexto do Geopandas</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#juncoes-espaciais-spatial-joins">5.6.5.4 Junções Espaciais (Spatial Joins)</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#operacoes-de-conjunto-com-sobreposicao-overlay">5.6.5.5 Operações de conjunto com sobreposição (overlay)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Alexandro Gularte Schafer
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=365ca57ee442770a23c6"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=365ca57ee442770a23c6"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>